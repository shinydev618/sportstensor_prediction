[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "mysql.connector",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mysql.connector",
        "description": "mysql.connector",
        "detail": "mysql.connector",
        "documentation": {}
    },
    {
        "label": "Error",
        "importPath": "mysql.connector",
        "description": "mysql.connector",
        "isExtraImport": true,
        "detail": "mysql.connector",
        "documentation": {}
    },
    {
        "label": "Error",
        "importPath": "mysql.connector",
        "description": "mysql.connector",
        "isExtraImport": true,
        "detail": "mysql.connector",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "IS_PROD",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "DB_HOST",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "DB_NAME",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "DB_USER",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "DB_PASSWORD",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "NETWORK",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "ODDS_API_KEY",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "ODDS_API_KEY",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "ODDS_API_KEY",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "ODDS_API_KEY",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "NETWORK",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "NETUID",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "IS_PROD",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "API_KEYS",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "TESTNET_VALI_HOTKEYS",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "NETWORK",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "NETUID",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "IS_PROD",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "api.db",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "api.db",
        "description": "api.db",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "schedule",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "schedule",
        "description": "schedule",
        "detail": "schedule",
        "documentation": {}
    },
    {
        "label": "pytz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytz",
        "description": "pytz",
        "detail": "pytz",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "api.fetch_odds",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Annotated",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "pydantic",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pydantic",
        "description": "pydantic",
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "PositiveInt",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "NonNegativeInt",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "model_serializer",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "print_exception",
        "importPath": "traceback",
        "description": "traceback",
        "isExtraImport": true,
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "print_exception",
        "importPath": "traceback",
        "description": "traceback",
        "isExtraImport": true,
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "bittensor",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bittensor",
        "description": "bittensor",
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "Balance",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "NeuronInfo",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "AxonInfo",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "PrometheusInfo",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "__ss58_format__",
        "importPath": "bittensor",
        "description": "bittensor",
        "isExtraImport": true,
        "detail": "bittensor",
        "documentation": {}
    },
    {
        "label": "uvicorn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uvicorn",
        "description": "uvicorn",
        "detail": "uvicorn",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Body",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Security",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "BackgroundTasks",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPBasicCredentials",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "HTTPBasic",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "APIKeyHeader",
        "importPath": "fastapi.security.api_key",
        "description": "fastapi.security.api_key",
        "isExtraImport": true,
        "detail": "fastapi.security.api_key",
        "documentation": {}
    },
    {
        "label": "StaticFiles",
        "importPath": "fastapi.staticfiles",
        "description": "fastapi.staticfiles",
        "isExtraImport": true,
        "detail": "fastapi.staticfiles",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "FileResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "starlette",
        "description": "starlette",
        "isExtraImport": true,
        "detail": "starlette",
        "documentation": {}
    },
    {
        "label": "Keypair",
        "importPath": "substrateinterface",
        "description": "substrateinterface",
        "isExtraImport": true,
        "detail": "substrateinterface",
        "documentation": {}
    },
    {
        "label": "sentry_sdk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sentry_sdk",
        "description": "sentry_sdk",
        "detail": "sentry_sdk",
        "documentation": {}
    },
    {
        "label": "ENABLE_APP",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "APP_PREDICTIONS_UNFULFILLED_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ENABLE_EMISSION_CONTROL",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EMISSION_CONTROL_UID",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EMISSION_CONTROL_PERC",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ENABLE_APP",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "DATA_SYNC_INTERVAL_IN_MINUTES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "APP_DATA_SYNC_INTERVAL_IN_MINUTES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PURGE_DEREGGED_MINERS_INTERVAL_IN_MINUTES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_BATCHSIZE_FOR_SCORING",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SCORING_INTERVAL_IN_MINUTES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ACTIVE_LEAGUES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_COMMITMENT_INTERVAL_IN_MINUTES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_SCORING_PERCENTAGES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROLLING_PREDICTION_THRESHOLD_BY_LEAGUE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_SENSITIVITY_ALPHAS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SENSITIVITY_ALPHA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "GAMMA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "TRANSITION_KAPPA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EXTREMIS_BETA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PARETO_MU",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PARETO_ALPHA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUES_ALLOWING_DRAWS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "IS_DEV",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_PREDICTION_TIME_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_PREDICTION_DAYS_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SCORING_CUTOFF_IN_DAYS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ACTIVE_LEAGUES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROLLING_PREDICTION_THRESHOLD_BY_LEAGUE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "COPYCAT_PUNISHMENT_START_DATE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ACTIVE_LEAGUES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_PREDICTION_DAYS_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROLLING_PREDICTION_THRESHOLD_BY_LEAGUE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_SENSITIVITY_ALPHAS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_GFILTER_FOR_WRONG_PREDICTION",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_BET_AMOUNT",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_INCR_PRED_COUNT_PERCENTAGE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_INCR_ROI_DIFF_PERCENTAGE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_MINIMUM_RHOS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_EDGE_SCORE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_MIN_EDGE_SCORE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_SCORING_WEIGHT",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUES_ALLOWING_DRAWS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SENSITIVITY_ALPHA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "GAMMA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "TRANSITION_KAPPA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EXTREMIS_BETA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_SCORING_PERCENTAGES",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PARETO_MU",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PARETO_ALPHA",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "COPYCAT_VARIANCE_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EXACT_MATCH_PREDICTIONS_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SUSPICIOUS_CONSECUTIVE_MATCHES_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EXACT_MATCH_PREDICTIONS_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SUSPICIOUS_CONSECUTIVE_MATCHES_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUES_ALLOWING_DRAWS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_MINIMUM_INTEGRITY_PREDICTIONS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "INTEGRITY_CHOICE_AGREEMENT_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "INTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_LOW",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "INTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_HIGH",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "INTEGRITY_PROB_CORRELATION_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_PREDICTION_DAYS_THRESHOLD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "NO_LEAGUE_COMMITMENT_PENALTY",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "NO_LEAGUE_COMMITMENT_GRACE_PERIOD",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MINER_RELIABILITY_CUTOFF_IN_DAYS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_MINER_RELIABILITY",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_GFILTER_FOR_WRONG_PREDICTION",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUES_ALLOWING_DRAWS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_MINIMUM_RHOS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_EDGE_SCORE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_MIN_EDGE_SCORE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_BET_AMOUNT",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_INCR_PRED_COUNT_PERCENTAGE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_INCR_ROI_DIFF_PERCENTAGE",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_SCORING_WEIGHT",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "IS_DEV",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "VALIDATOR_TIMEOUT",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MATCH_ODDS_CUTOFF_IN_DAYS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUES_ALLOWING_DRAWS",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_BET_AMOUNT",
        "importPath": "common.constants",
        "description": "common.constants",
        "isExtraImport": true,
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "secrets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "secrets",
        "description": "secrets",
        "detail": "secrets",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RotatingFileHandler",
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "isExtraImport": true,
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "BaseNeuron",
        "importPath": "base.neuron",
        "description": "base.neuron",
        "isExtraImport": true,
        "detail": "base.neuron",
        "documentation": {}
    },
    {
        "label": "BaseNeuron",
        "importPath": "base.neuron",
        "description": "base.neuron",
        "isExtraImport": true,
        "detail": "base.neuron",
        "documentation": {}
    },
    {
        "label": "add_miner_args",
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "isExtraImport": true,
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "check_config",
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "isExtraImport": true,
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "add_args",
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "isExtraImport": true,
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "isExtraImport": true,
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "add_validator_args",
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "isExtraImport": true,
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ttl_get_block",
        "importPath": "base.utils.misc",
        "description": "base.utils.misc",
        "isExtraImport": true,
        "detail": "base.utils.misc",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base",
        "description": "base",
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "__spec_version__",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "MockSubtensor",
        "importPath": "base.mock",
        "description": "base.mock",
        "isExtraImport": true,
        "detail": "base.mock",
        "documentation": {}
    },
    {
        "label": "MockMetagraph",
        "importPath": "base.mock",
        "description": "base.mock",
        "isExtraImport": true,
        "detail": "base.mock",
        "documentation": {}
    },
    {
        "label": "MockDendrite",
        "importPath": "base.mock",
        "description": "base.mock",
        "isExtraImport": true,
        "detail": "base.mock",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "get_league_from_string",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Sport",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "get_league_from_string",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "get_league_from_string",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Sport",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "get_league_from_string",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPredictionWithMatchData",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPredictionWithMatchData",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPredictionWithMatchData",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPredictionWithMatchData",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPredictionWithMatchData",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPredictionWithMatchData",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPredictionWithMatchData",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "get_probablity_choice_from_string",
        "importPath": "common.data",
        "description": "common.data",
        "isExtraImport": true,
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "dataclasses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dataclasses",
        "description": "dataclasses",
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "concurrent",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "concurrent",
        "description": "concurrent",
        "detail": "concurrent",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "StreamPrompting",
        "importPath": "protocol",
        "description": "protocol",
        "isExtraImport": true,
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "StreamPrompting",
        "importPath": "protocol",
        "description": "protocol",
        "isExtraImport": true,
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "Send",
        "importPath": "starlette.types",
        "description": "starlette.types",
        "isExtraImport": true,
        "detail": "starlette.types",
        "documentation": {}
    },
    {
        "label": "GPT2Tokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "check_config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "StreamingResponse",
        "importPath": "starlette.responses",
        "description": "starlette.responses",
        "isExtraImport": true,
        "detail": "starlette.responses",
        "documentation": {}
    },
    {
        "label": "BaseMinerNeuron",
        "importPath": "base.miner",
        "description": "base.miner",
        "isExtraImport": true,
        "detail": "base.miner",
        "documentation": {}
    },
    {
        "label": "GetLeagueCommitments",
        "importPath": "common.protocol",
        "description": "common.protocol",
        "isExtraImport": true,
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetMatchPrediction",
        "importPath": "common.protocol",
        "description": "common.protocol",
        "isExtraImport": true,
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetLeagueCommitments",
        "importPath": "common.protocol",
        "description": "common.protocol",
        "isExtraImport": true,
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetMatchPrediction",
        "importPath": "common.protocol",
        "description": "common.protocol",
        "isExtraImport": true,
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetMatchPrediction",
        "importPath": "common.protocol",
        "description": "common.protocol",
        "isExtraImport": true,
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetMatchPrediction",
        "importPath": "common.protocol",
        "description": "common.protocol",
        "isExtraImport": true,
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetLeagueCommitments",
        "importPath": "common.protocol",
        "description": "common.protocol",
        "isExtraImport": true,
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetMatchPrediction",
        "importPath": "common.protocol",
        "description": "common.protocol",
        "isExtraImport": true,
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "make_match_prediction",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "make_match_prediction",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "isExtraImport": true,
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "wandb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wandb",
        "description": "wandb",
        "detail": "wandb",
        "documentation": {}
    },
    {
        "label": "vali_utils.utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "vali_utils.scoring_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "calculate_edge",
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "isExtraImport": true,
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "compute_significance_score",
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "isExtraImport": true,
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "calculate_clv",
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "isExtraImport": true,
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "calculate_incentive_score",
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "isExtraImport": true,
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "apply_gaussian_filter",
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "isExtraImport": true,
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "apply_pareto",
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "isExtraImport": true,
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "apply_no_prediction_response_penalties",
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "isExtraImport": true,
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "BaseValidatorNeuron",
        "importPath": "base.validator",
        "description": "base.validator",
        "isExtraImport": true,
        "detail": "base.validator",
        "documentation": {}
    },
    {
        "label": "aiohttp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiohttp",
        "description": "aiohttp",
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "ClientSession",
        "importPath": "aiohttp",
        "description": "aiohttp",
        "isExtraImport": true,
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "ClientSession",
        "importPath": "aiohttp",
        "description": "aiohttp",
        "isExtraImport": true,
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "BasicAuth",
        "importPath": "aiohttp",
        "description": "aiohttp",
        "isExtraImport": true,
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "BaseballPredictionModel",
        "importPath": "st.models.baseball",
        "description": "st.models.baseball",
        "isExtraImport": true,
        "detail": "st.models.baseball",
        "documentation": {}
    },
    {
        "label": "BasketballPredictionModel",
        "importPath": "st.models.basketball",
        "description": "st.models.basketball",
        "isExtraImport": true,
        "detail": "st.models.basketball",
        "documentation": {}
    },
    {
        "label": "FootballPredictionModel",
        "importPath": "st.models.football",
        "description": "st.models.football",
        "isExtraImport": true,
        "detail": "st.models.football",
        "documentation": {}
    },
    {
        "label": "SoccerPredictionModel",
        "importPath": "st.models.soccer",
        "description": "st.models.soccer",
        "isExtraImport": true,
        "detail": "st.models.soccer",
        "documentation": {}
    },
    {
        "label": "SoccerPredictionModel",
        "importPath": "st.models.soccer",
        "description": "st.models.soccer",
        "isExtraImport": true,
        "detail": "st.models.soccer",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "storage.validator_storage",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "storage.validator_storage",
        "description": "storage.validator_storage",
        "detail": "storage.validator_storage",
        "documentation": {}
    },
    {
        "label": "ValidatorStorage",
        "importPath": "storage.validator_storage",
        "description": "storage.validator_storage",
        "isExtraImport": true,
        "detail": "storage.validator_storage",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "get_storage",
        "importPath": "storage.sqlite_validator_storage",
        "description": "storage.sqlite_validator_storage",
        "isExtraImport": true,
        "detail": "storage.sqlite_validator_storage",
        "documentation": {}
    },
    {
        "label": "get_storage",
        "importPath": "storage.sqlite_validator_storage",
        "description": "storage.sqlite_validator_storage",
        "isExtraImport": true,
        "detail": "storage.sqlite_validator_storage",
        "documentation": {}
    },
    {
        "label": "get_storage",
        "importPath": "storage.sqlite_validator_storage",
        "description": "storage.sqlite_validator_storage",
        "isExtraImport": true,
        "detail": "storage.sqlite_validator_storage",
        "documentation": {}
    },
    {
        "label": "SqliteValidatorStorage",
        "importPath": "storage.sqlite_validator_storage",
        "description": "storage.sqlite_validator_storage",
        "isExtraImport": true,
        "detail": "storage.sqlite_validator_storage",
        "documentation": {}
    },
    {
        "label": "CopycatDetectionController",
        "importPath": "vali_utils.copycat_controller",
        "description": "vali_utils.copycat_controller",
        "isExtraImport": true,
        "detail": "vali_utils.copycat_controller",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "MockWallet",
        "importPath": "bittensor.mock.wallet_mock",
        "description": "bittensor.mock.wallet_mock",
        "isExtraImport": true,
        "detail": "bittensor.mock.wallet_mock",
        "documentation": {}
    },
    {
        "label": "get_mock_coldkey",
        "importPath": "bittensor.mock.wallet_mock",
        "description": "bittensor.mock.wallet_mock",
        "isExtraImport": true,
        "detail": "bittensor.mock.wallet_mock",
        "documentation": {}
    },
    {
        "label": "get_mock_hotkey",
        "importPath": "bittensor.mock.wallet_mock",
        "description": "bittensor.mock.wallet_mock",
        "isExtraImport": true,
        "detail": "bittensor.mock.wallet_mock",
        "documentation": {}
    },
    {
        "label": "get_mock_keypair",
        "importPath": "bittensor.mock.wallet_mock",
        "description": "bittensor.mock.wallet_mock",
        "isExtraImport": true,
        "detail": "bittensor.mock.wallet_mock",
        "documentation": {}
    },
    {
        "label": "get_mock_wallet",
        "importPath": "bittensor.mock.wallet_mock",
        "description": "bittensor.mock.wallet_mock",
        "isExtraImport": true,
        "detail": "bittensor.mock.wallet_mock",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "rich.text",
        "description": "rich.text",
        "isExtraImport": true,
        "detail": "rich.text",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "PredictionIntegrityController",
        "importPath": "vali_utils.prediction_integrity_controller",
        "description": "vali_utils.prediction_integrity_controller",
        "isExtraImport": true,
        "detail": "vali_utils.prediction_integrity_controller",
        "documentation": {}
    },
    {
        "label": "PredictionIntegrityController",
        "importPath": "vali_utils.prediction_integrity_controller",
        "description": "vali_utils.prediction_integrity_controller",
        "isExtraImport": true,
        "detail": "vali_utils.prediction_integrity_controller",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "MockDendrite",
        "importPath": "prompting.mock",
        "description": "prompting.mock",
        "isExtraImport": true,
        "detail": "prompting.mock",
        "documentation": {}
    },
    {
        "label": "MockMetagraph",
        "importPath": "prompting.mock",
        "description": "prompting.mock",
        "isExtraImport": true,
        "detail": "prompting.mock",
        "documentation": {}
    },
    {
        "label": "MockSubtensor",
        "importPath": "prompting.mock",
        "description": "prompting.mock",
        "isExtraImport": true,
        "detail": "prompting.mock",
        "documentation": {}
    },
    {
        "label": "PromptingSynapse",
        "importPath": "prompting.protocol",
        "description": "prompting.protocol",
        "isExtraImport": true,
        "detail": "prompting.protocol",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "storage.sqlite_validator_storage import SqliteValidatorStorage  # Ensure correct",
        "description": "storage.sqlite_validator_storage import SqliteValidatorStorage  # Ensure correct",
        "isExtraImport": true,
        "detail": "storage.sqlite_validator_storage import SqliteValidatorStorage  # Ensure correct",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "importPath": "neurons.validator",
        "description": "neurons.validator",
        "isExtraImport": true,
        "detail": "neurons.validator",
        "documentation": {}
    },
    {
        "label": "Validator",
        "importPath": "neurons.validator",
        "description": "neurons.validator",
        "isExtraImport": true,
        "detail": "neurons.validator",
        "documentation": {}
    },
    {
        "label": "Neuron",
        "importPath": "neurons.miner",
        "description": "neurons.miner",
        "isExtraImport": true,
        "detail": "neurons.miner",
        "documentation": {}
    },
    {
        "label": "Dummy",
        "importPath": "template.protocol",
        "description": "template.protocol",
        "isExtraImport": true,
        "detail": "template.protocol",
        "documentation": {}
    },
    {
        "label": "forward",
        "importPath": "template.validator.forward",
        "description": "template.validator.forward",
        "isExtraImport": true,
        "detail": "template.validator.forward",
        "documentation": {}
    },
    {
        "label": "get_random_uids",
        "importPath": "template.utils.uids",
        "description": "template.utils.uids",
        "isExtraImport": true,
        "detail": "template.utils.uids",
        "documentation": {}
    },
    {
        "label": "get_rewards",
        "importPath": "template.validator.reward",
        "description": "template.validator.reward",
        "isExtraImport": true,
        "detail": "template.validator.reward",
        "documentation": {}
    },
    {
        "label": "BaseValidatorNeuron",
        "importPath": "template.base.validator",
        "description": "template.base.validator",
        "isExtraImport": true,
        "detail": "template.base.validator",
        "documentation": {}
    },
    {
        "label": "StatisticalAnalyzer",
        "importPath": "vali_utils.analysis_utils",
        "description": "vali_utils.analysis_utils",
        "isExtraImport": true,
        "detail": "vali_utils.analysis_utils",
        "documentation": {}
    },
    {
        "label": "spearmanr",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "pareto",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "HTTPBasicAuth",
        "importPath": "requests.auth",
        "description": "requests.auth",
        "isExtraImport": true,
        "detail": "requests.auth",
        "documentation": {}
    },
    {
        "label": "scoring_utils",
        "importPath": "vali_utils",
        "description": "vali_utils",
        "isExtraImport": true,
        "detail": "vali_utils",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "parse_requirements",
        "importPath": "pkg_resources",
        "description": "pkg_resources",
        "isExtraImport": true,
        "detail": "pkg_resources",
        "documentation": {}
    },
    {
        "label": "env_path",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "env_path = os.path.join(os.path.dirname(__file__), 'api.env')\n# Load the environment variables from the api.env file\nload_dotenv(dotenv_path=env_path)\nIS_PROD = False if os.getenv(\"IS_PROD\") == \"False\" else True\nNETWORK = None\nNETUID = 41\nif not IS_PROD:\n    NETWORK = \"test\"\n    NETUID = 172\nDB_HOST = os.getenv(\"DB_HOST\")",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "IS_PROD",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "IS_PROD = False if os.getenv(\"IS_PROD\") == \"False\" else True\nNETWORK = None\nNETUID = 41\nif not IS_PROD:\n    NETWORK = \"test\"\n    NETUID = 172\nDB_HOST = os.getenv(\"DB_HOST\")\nDB_NAME = os.getenv(\"DB_NAME\")\nDB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "NETWORK",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "NETWORK = None\nNETUID = 41\nif not IS_PROD:\n    NETWORK = \"test\"\n    NETUID = 172\nDB_HOST = os.getenv(\"DB_HOST\")\nDB_NAME = os.getenv(\"DB_NAME\")\nDB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")\nAPI_KEYS = os.getenv('API_KEYS')",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "NETUID",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "NETUID = 41\nif not IS_PROD:\n    NETWORK = \"test\"\n    NETUID = 172\nDB_HOST = os.getenv(\"DB_HOST\")\nDB_NAME = os.getenv(\"DB_NAME\")\nDB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")\nAPI_KEYS = os.getenv('API_KEYS')\nODDS_API_KEY=os.getenv('ODDS_API_KEY')",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "DB_HOST",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "DB_HOST = os.getenv(\"DB_HOST\")\nDB_NAME = os.getenv(\"DB_NAME\")\nDB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")\nAPI_KEYS = os.getenv('API_KEYS')\nODDS_API_KEY=os.getenv('ODDS_API_KEY')\nTESTNET_VALI_HOTKEYS = json.loads(os.environ[\"TESTNET_VALI_HOTKEYS\"])",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "DB_NAME",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "DB_NAME = os.getenv(\"DB_NAME\")\nDB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")\nAPI_KEYS = os.getenv('API_KEYS')\nODDS_API_KEY=os.getenv('ODDS_API_KEY')\nTESTNET_VALI_HOTKEYS = json.loads(os.environ[\"TESTNET_VALI_HOTKEYS\"])",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "DB_USER",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "DB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")\nAPI_KEYS = os.getenv('API_KEYS')\nODDS_API_KEY=os.getenv('ODDS_API_KEY')\nTESTNET_VALI_HOTKEYS = json.loads(os.environ[\"TESTNET_VALI_HOTKEYS\"])",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "DB_PASSWORD",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "DB_PASSWORD = os.getenv(\"DB_PASSWORD\")\nAPI_KEYS = os.getenv('API_KEYS')\nODDS_API_KEY=os.getenv('ODDS_API_KEY')\nTESTNET_VALI_HOTKEYS = json.loads(os.environ[\"TESTNET_VALI_HOTKEYS\"])",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "API_KEYS",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "API_KEYS = os.getenv('API_KEYS')\nODDS_API_KEY=os.getenv('ODDS_API_KEY')\nTESTNET_VALI_HOTKEYS = json.loads(os.environ[\"TESTNET_VALI_HOTKEYS\"])",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "TESTNET_VALI_HOTKEYS",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "TESTNET_VALI_HOTKEYS = json.loads(os.environ[\"TESTNET_VALI_HOTKEYS\"])",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "generate_uuid",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def generate_uuid():\n    return os.urandom(16).hex()\nGET_MATCH_QUERY = \"\"\"\n    SELECT\n        mlo.*,\n        mo.homeTeamOdds,\n        mo.awayTeamOdds,\n        mo.drawOdds,\n        mo.lastUpdated,\n        (SELECT COUNT(*) FROM match_odds mo WHERE mlo.oddsapiMatchId = mo.oddsapiMatchId AND mo.lastUpdated IS NOT NULL) AS odds_count,",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "match_id_exists",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def match_id_exists(match_id):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT COUNT(*) FROM matches WHERE matchId = %s\", (match_id,))\n        count = cursor.fetchone()[0]\n        return count > 0\n    except Exception as e:\n        logging.error(\"Failed to check if match exists in MySQL database\", exc_info=True)\n        return False",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "match_odds_id_exists",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def match_odds_id_exists(match_odds_id):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT COUNT(*) FROM match_odds WHERE id = %s\", (match_odds_id,))\n        count = cursor.fetchone()[0]\n        return count > 0\n    except Exception as e:\n        logging.error(\"Failed to check if match_odds exists in MySQL database\", exc_info=True)\n        return False",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_matches",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_matches(all=False):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        cursor.execute(\"SET @current_time_utc = CONVERT_TZ(NOW(), @@session.time_zone, '+00:00')\")\n        query = GET_MATCH_QUERY\n        if not all:\n            query += \"\"\"\n                WHERE mlo.matchDate BETWEEN @current_time_utc - INTERVAL 10 DAY AND @current_time_utc + INTERVAL 48 HOUR\n            \"\"\"",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_upcoming_matches",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_upcoming_matches():\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        # Set the current time in UTC\n        cursor.execute(\"SET @current_time_utc = CONVERT_TZ(NOW(), @@session.time_zone, '+00:00')\")\n        query = GET_MATCH_QUERY + \"\"\"\n           WHERE mlo.matchDate BETWEEN @current_time_utc AND @current_time_utc + INTERVAL 48 HOUR\n        \"\"\"\n        cursor.execute(query)",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_matches_with_no_odds",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_matches_with_no_odds():\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        query = \"\"\"\n            SELECT ml.*, m.*\n            FROM matches_lookup ml\n            LEFT JOIN matches m\n            ON ml.matchId = m.matchId\n        \"\"\"",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_stored_odds",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_stored_odds(lastUpdated = None):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        if lastUpdated:\n            query = \"\"\"\n                SELECT mo.*, o.homeTeamName, o.awayTeamName, o.commence_time, o.league\n                FROM (\n                    SELECT id, oddsapiMatchId, homeTeamOdds, awayTeamOdds, drawOdds, lastUpdated\n                    FROM match_odds",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_stored_spread_odds",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_stored_spread_odds(lastUpdated = None):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        if lastUpdated:\n            query = \"\"\"\n                SELECT mo.*, o.homeTeamName, o.awayTeamName, o.commence_time, o.league\n                FROM (\n                    SELECT id, oddsapiMatchId, homeTeamSpreadOdds, awayTeamSpreadOdds, lastUpdated\n                    FROM match_spread_odds",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_team_records",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_team_records(team_name, league, start_date=None, end_date=None):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        query = \"\"\"\n            WITH MatchesWithSpread AS (\n                SELECT \n                    m.*,\n                    mso.homeTeamSpreadOdds,\n                    mso.awayTeamSpreadOdds",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_match_odds_by_id",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_match_odds_by_id(match_id):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        if match_id:\n            query = \"\"\"\n                SELECT mo.*, ml.matchId\n                FROM match_odds mo\n                LEFT JOIN matches_lookup ml ON mo.oddsapiMatchId = ml.oddsapiMatchId\n                WHERE ml.matchId = %s AND mo.lastUpdated IS NOT NULL",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_matches_with_missing_odds",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_matches_with_missing_odds():\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        # Set the current time in UTC\n        cursor.execute(\"SET @current_time_utc = CONVERT_TZ(NOW(), @@session.time_zone, '+00:00')\")\n        query = \"\"\"\n            SELECT\n                mlo.*,\n                (",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_live_matches",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_live_matches():\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        # Set the current time in UTC\n        cursor.execute(\"SET @current_time_utc = CONVERT_TZ(NOW(), @@session.time_zone, '+00:00')\")\n        query = \"\"\"\n            SELECT\n                m.matchId,\n                m.matchDate,",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_completed_matches",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_completed_matches(start_date, end_date=None, league=None, no_spread_odds=False):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        query = \"\"\"\n            SELECT\n                m.matchId,\n                m.matchDate,\n                m.homeTeamName,\n                m.awayTeamName,",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_match_by_id",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_match_by_id(match_id):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        query = GET_MATCH_QUERY + \"\"\"\n            WHERE mlo.matchId = %s\n        \"\"\"\n        cursor.execute(query, (match_id,))\n        match = cursor.fetchone()\n        return match",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "insert_match",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def insert_match(match_id, event, sport_type, is_complete, current_utc_time):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.execute(\n            \"\"\"\n            INSERT INTO matches (matchId, matchDate, sport, homeTeamName, awayTeamName, homeTeamScore, awayTeamScore, matchLeague, isComplete, lastUpdated) \n            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)\n            ON DUPLICATE KEY UPDATE \n                matchDate=VALUES(matchDate),",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "insert_match_oddsapi",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def insert_match_oddsapi(match_id, event, sport_type, home_team_score, away_team_score, is_complete, current_utc_time):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.execute(\n            \"\"\"\n            INSERT INTO matches_oddsapi (oddsapiMatchId, matchDate, sport, homeTeamName, awayTeamName, homeTeamScore, awayTeamScore, sport_title, isComplete, lastUpdated) \n            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)\n            ON DUPLICATE KEY UPDATE \n                matchDate=VALUES(matchDate),",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_match_oddsapi_by_id",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_match_oddsapi_by_id(match_id):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor(dictionary=True)\n        query = \"\"\"\n            SELECT *\n            FROM matches_oddsapi\n            LEFT JOIN matches_lookup ON matches_oddsapi.oddsapiMatchId = matches_lookup.oddsapiMatchId\n            WHERE matches_lookup.matchId = %s\n        \"\"\"",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "insert_sportsdb_match_lookup",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def insert_sportsdb_match_lookup(match_id, sportsdb_match_id):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.execute(\n            \"\"\"\n            INSERT IGNORE INTO matches_lookup (matchId, sportsdbMatchId) \n            VALUES (%s, %s)\n            \"\"\",\n            (",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "query_sportsdb_match_lookup",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def query_sportsdb_match_lookup(sportsdb_match_id):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT matchId FROM matches_lookup WHERE sportsdbMatchId = %s\",\n            (sportsdb_match_id,),\n        )\n        match_id = cursor.fetchone()\n        return match_id[0] if match_id else None",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "setup_match_odds_table",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def setup_match_odds_table():\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        # Check if the pinnacle_bookmaker column exists\n        c.execute(\"SHOW COLUMNS FROM match_odds LIKE 'pinnacle_bookmaker';\")\n        result = c.fetchone()\n        # If the column does not exist, add it\n        if not result:\n            c.execute(",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "insert_match_odds_bulk",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def insert_match_odds_bulk(match_data):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.executemany(\n            \"\"\"\n            INSERT IGNORE INTO match_odds (id, oddsapiMatchId, homeTeamOdds, awayTeamOdds, drawOdds, pinnacle_bookmaker, lastUpdated) \n            VALUES (%s, %s, %s, %s, %s, %s, %s)\n            \"\"\",\n            match_data,",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "insert_match_spread_odds_bulk",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def insert_match_spread_odds_bulk(match_data):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.executemany(\n            \"\"\"\n            INSERT IGNORE INTO match_spread_odds (id, oddsapiMatchId, homeTeamSpreadOdds, awayTeamSpreadOdds, pinnacle_bookmaker, lastUpdated) \n            VALUES (%s, %s, %s, %s, %s, %s)\n            \"\"\",\n            match_data,",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_average_pinnacle",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_average_pinnacle():\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.execute(\n            \"\"\"\n                SELECT AVG(vig) AS average_vig\n                FROM (\n                    SELECT \n                        (1 / homeTeamOdds + 1 / awayTeamOdds + ",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "insert_match_lookups_bulk",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def insert_match_lookups_bulk(match_lookup_data):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.executemany(\n            \"\"\"\n            INSERT IGNORE INTO matches_lookup (matchId, oddsapiMatchId) \n            VALUES (%s, %s)\n            ON DUPLICATE KEY UPDATE\n                oddsapiMatchId=VALUES(oddsapiMatchId)",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "insert_odds_bulk",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def insert_odds_bulk(odds_to_store):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.executemany(\n            \"\"\"\n            INSERT IGNORE INTO odds (oddsapiMatchId, league, homeTeamName, awayTeamName, commence_time, lastUpdated)\n            VALUES (%s, %s, %s, %s, %s, %s)\n            ON DUPLICATE KEY UPDATE\n                commence_time=VALUES(commence_time),",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "upload_prediction_edge_results",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def upload_prediction_edge_results(prediction_results):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        prediction_edge_scores_table_name = \"MatchPredictionEdgeResults\"\n        if not IS_PROD:\n            prediction_edge_scores_table_name += \"_test\"\n        # Delete existing rows for today's date for each miner_uid and vali_hotkey\n        for uid, score_data in prediction_results[\"miner_scores\"].items():\n            delete_sql = f\"\"\"",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_prediction_edge_results",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_prediction_edge_results(vali_hotkey, miner_hotkey=None, miner_id=None, league=None, date=None, end_date=None, include_deregistered=False, count=10):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor(dictionary=True)\n        prediction_edge_results_table_name = \"MatchPredictionEdgeResults\"\n        params = [vali_hotkey]\n        miners_table_name = \"Miners\"\n        if not IS_PROD:\n            prediction_edge_results_table_name += \"_test\"\n            miners_table_name += \"_test\"",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "upload_scored_predictions",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def upload_scored_predictions(predictions, vali_hotkey):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        current_utc_time = dt.datetime.now(timezone.utc)\n        current_utc_time = current_utc_time.strftime(\"%Y-%m-%d %H:%M:%S\")\n        print(f\"Content of predictions: {predictions}\")\n        predictions = predictions.get('predictions', [])\n        # Ensure predictions is a list\n        if not isinstance(predictions, list):",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "update_miner_reg_statuses",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def update_miner_reg_statuses(active_uids, active_hotkeys):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        miners_table_name = \"Miners\"\n        if not IS_PROD:\n            miners_table_name += \"_test\"\n        # mark all as unregistered first as we'll update only the active ones next\n        c.execute(\n            f\"\"\"",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "insert_or_update_miner_coldkeys_and_ages",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def insert_or_update_miner_coldkeys_and_ages(data_to_update):\n    try:\n        conn = get_db_conn()\n        cursor = conn.cursor()\n        miners_table_name = \"Miners\"\n        if not IS_PROD:\n            miners_table_name += \"_test\"\n        # mark all as unregistered first as we'll update only the active ones next\n        cursor.execute(\n            f\"\"\"",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_prediction_results_by_league",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_prediction_results_by_league(vali_hotkey, league=None, miner_hotkey=None):\n    try:\n        conn = get_db_conn()\n        c = conn.cursor(dictionary=True)\n        prediction_scores_table_name = \"MatchPredictionsScored\"\n        params = [vali_hotkey]\n        miners_table_name = \"Miners\"\n        if not IS_PROD:\n            prediction_scores_table_name += \"_test\"\n            miners_table_name += \"_test\"",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "create_tables",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def create_tables():\n    c = None\n    conn = None\n    try:\n        conn = get_db_conn()\n        c = conn.cursor()\n        c.execute(\n            \"\"\"\n        CREATE TABLE IF NOT EXISTS matches (\n            matchId VARCHAR(50) PRIMARY KEY,",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "get_db_conn",
        "kind": 2,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "def get_db_conn():\n    try:\n        conn = mysql.connector.connect(\n            host=DB_HOST,\n            database=DB_NAME,\n            user=DB_USER,\n            password=DB_PASSWORD,\n        )\n        return conn\n    except mysql.connector.Error as e:",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "GET_MATCH_QUERY",
        "kind": 5,
        "importPath": "api.db",
        "description": "api.db",
        "peekOfCode": "GET_MATCH_QUERY = \"\"\"\n    SELECT\n        mlo.*,\n        mo.homeTeamOdds,\n        mo.awayTeamOdds,\n        mo.drawOdds,\n        mo.lastUpdated,\n        (SELECT COUNT(*) FROM match_odds mo WHERE mlo.oddsapiMatchId = mo.oddsapiMatchId AND mo.lastUpdated IS NOT NULL) AS odds_count,\n        CASE \n            WHEN EXISTS (",
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "parse_datetime_with_optional_timezone",
        "kind": 2,
        "importPath": "api.fetch_matches",
        "description": "api.fetch_matches",
        "peekOfCode": "def parse_datetime_with_optional_timezone(timestamp):\n    if isinstance(timestamp, (int, float)) or timestamp.isdigit():\n        # Handle Unix timestamp (seconds since epoch)\n        return datetime.fromtimestamp(float(timestamp), tz=timezone.utc)\n    try:\n        # Try parsing with timezone\n        return datetime.strptime(timestamp, \"%Y-%m-%dT%H:%M:%S%z\")\n    except ValueError:\n        try:\n            # Try parsing without timezone and assume UTC",
        "detail": "api.fetch_matches",
        "documentation": {}
    },
    {
        "label": "create_match_id",
        "kind": 2,
        "importPath": "api.fetch_matches",
        "description": "api.fetch_matches",
        "peekOfCode": "def create_match_id():\n    # generate a unique uuid for the match. make sure it does not already exist.\n    match_id = db.generate_uuid()\n    while db.match_id_exists(match_id):\n        print(f\"Match ID {match_id} already exists. Generating a new one.\")\n        match_id = db.generate_uuid()\n    return match_id\ndef create_match_id_deprecated(home_team, away_team, match_date):\n    # Extract the first 10 letters of home and away team names\n    home_prefix = home_team.replace(\" \", \"\")[:10]",
        "detail": "api.fetch_matches",
        "documentation": {}
    },
    {
        "label": "create_match_id_deprecated",
        "kind": 2,
        "importPath": "api.fetch_matches",
        "description": "api.fetch_matches",
        "peekOfCode": "def create_match_id_deprecated(home_team, away_team, match_date):\n    # Extract the first 10 letters of home and away team names\n    home_prefix = home_team.replace(\" \", \"\")[:10]\n    away_prefix = away_team.replace(\" \", \"\")[:10]\n    formatted_date = parse_datetime_with_optional_timezone(match_date).strftime(\n        \"%Y%m%d%H%M\"\n    )\n    return f\"{home_prefix}{away_prefix}{formatted_date}\"\ndef fetch_and_store_events():\n    api_endpoints_url = (",
        "detail": "api.fetch_matches",
        "documentation": {}
    },
    {
        "label": "fetch_and_store_events",
        "kind": 2,
        "importPath": "api.fetch_matches",
        "description": "api.fetch_matches",
        "peekOfCode": "def fetch_and_store_events():\n    api_endpoints_url = (\n        \"https://docs.google.com/spreadsheets/d/e/2PACX-1vQJcedkDc0c3rijp6gX9eSiq1QDRpMlbiZMywPc3amzznLyiLSOqc6dfbz5Hd18dqPgQVbvp91NSCSE/pub?gid=1997764475&single=true&output=csv\"\n        if NETWORK == \"test\"\n        else \"https://docs.google.com/spreadsheets/d/e/2PACX-1vQJcedkDc0c3rijp6gX9eSiq1QDRpMlbiZMywPc3amzznLyiLSOqc6dfbz5Hd18dqPgQVbvp91NSCSE/pub?gid=0&single=true&output=csv\"\n    )\n    # get event API endpoints from CSV URL and load them into our urls list\n    try:\n        response = requests.get(api_endpoints_url)\n        response.raise_for_status()",
        "detail": "api.fetch_matches",
        "documentation": {}
    },
    {
        "label": "fetch_and_store_events_oddsapi",
        "kind": 2,
        "importPath": "api.fetch_matches",
        "description": "api.fetch_matches",
        "peekOfCode": "def fetch_and_store_events_oddsapi():\n    api_endpoints_url = (\n        \"https://docs.google.com/spreadsheets/d/e/2PACX-1vQJcedkDc0c3rijp6gX9eSiq1QDRpMlbiZMywPc3amzznLyiLSOqc6dfbz5Hd18dqPgQVbvp91NSCSE/pub?gid=1997764475&single=true&output=csv\"\n        if NETWORK == \"test\"\n        else \"https://docs.google.com/spreadsheets/d/e/2PACX-1vQJcedkDc0c3rijp6gX9eSiq1QDRpMlbiZMywPc3amzznLyiLSOqc6dfbz5Hd18dqPgQVbvp91NSCSE/pub?gid=0&single=true&output=csv\"\n    )\n    # get leagues that are active\n    active_leagues = []\n    try:\n        response = requests.get(api_endpoints_url)",
        "detail": "api.fetch_matches",
        "documentation": {}
    },
    {
        "label": "sport_mapping",
        "kind": 5,
        "importPath": "api.fetch_matches",
        "description": "api.fetch_matches",
        "peekOfCode": "sport_mapping = {\"SOCCER\": 1, \"AMERICAN FOOTBALL\": 2, \"BASEBALL\": 3, \"BASKETBALL\": 4}\nODDSAPI_SPORTS_TYPES = [\n    {\n        'sport_key': 'baseball_mlb',\n        'sport_id': 3,\n        'league': 'MLB',\n    },\n    {\n        'sport_key': 'americanfootball_nfl',\n        'sport_id': 2,",
        "detail": "api.fetch_matches",
        "documentation": {}
    },
    {
        "label": "ODDSAPI_SPORTS_TYPES",
        "kind": 5,
        "importPath": "api.fetch_matches",
        "description": "api.fetch_matches",
        "peekOfCode": "ODDSAPI_SPORTS_TYPES = [\n    {\n        'sport_key': 'baseball_mlb',\n        'sport_id': 3,\n        'league': 'MLB',\n    },\n    {\n        'sport_key': 'americanfootball_nfl',\n        'sport_id': 2,\n        'league': 'NFL',",
        "detail": "api.fetch_matches",
        "documentation": {}
    },
    {
        "label": "get_odds_apis_by_match",
        "kind": 2,
        "importPath": "api.fetch_match_odds",
        "description": "api.fetch_match_odds",
        "peekOfCode": "def get_odds_apis_by_match(stored_odds, match):\n    matchId = match.get(\"matchId\")\n    if matchId is None:\n        return None\n    homeTeamName = match.get(\"homeTeamName\")\n    awayTeamName = match.get(\"awayTeamName\")\n    matchDate = match.get(\"matchDate\")\n    matchLeague = match.get(\"matchLeague\")\n    str_matchDate = pytz.utc.localize(matchDate).strftime(\"%Y-%m-%dT%HZ\")\n    # Extract just the date part from match_date",
        "detail": "api.fetch_match_odds",
        "documentation": {}
    },
    {
        "label": "fetch_and_store_match_lookups",
        "kind": 2,
        "importPath": "api.fetch_match_odds",
        "description": "api.fetch_match_odds",
        "peekOfCode": "def fetch_and_store_match_lookups():\n    logging.info(f\"=============Starting to update matches lookup with new odds apis=============\")\n    matchesWithNoOdds = db.get_matches_with_no_odds()\n    stored_odds = db.get_stored_odds()\n    matches_odds_apis = []\n    try:\n        for match in matchesWithNoOdds:\n            matches_odds_api = get_odds_apis_by_match(stored_odds, match)\n            if matches_odds_api:\n                matches_odds_apis.append(matches_odds_api)",
        "detail": "api.fetch_match_odds",
        "documentation": {}
    },
    {
        "label": "merge_intervals",
        "kind": 2,
        "importPath": "api.fetch_missing_odds",
        "description": "api.fetch_missing_odds",
        "peekOfCode": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current_start, current_end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        # Check if there is an overlap\n        if current_start <= last_end:",
        "detail": "api.fetch_missing_odds",
        "documentation": {}
    },
    {
        "label": "fetch_odds",
        "kind": 2,
        "importPath": "api.fetch_missing_odds",
        "description": "api.fetch_missing_odds",
        "peekOfCode": "def fetch_odds(api_url, start, intervals):\n    # Initialize the current interval index\n    current_index = 0\n    while current_index < len(intervals):\n        # Get the current interval\n        current_interval = intervals[current_index]\n        interval_start, interval_end = current_interval\n        # Check if the start is within the current interval\n        if not (interval_start <= start <= interval_end):\n            logging.error(\"Start timestamp is outside the interval.\")",
        "detail": "api.fetch_missing_odds",
        "documentation": {}
    },
    {
        "label": "fetch_missing_odds",
        "kind": 2,
        "importPath": "api.fetch_missing_odds",
        "description": "api.fetch_missing_odds",
        "peekOfCode": "def fetch_missing_odds():\n    completed_matches = db.get_matches_with_missing_odds()\n    history_intervals = []\n    for completed_match in completed_matches:\n        matchDate = completed_match['matchDate']\n        matchLeague = completed_match['matchLeague']\n        oddsapiMatchId = completed_match['oddsapiMatchId']\n        t_24 = (matchDate - timedelta(hours=24)).strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n        t_0 = matchDate.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n        if completed_match['oddsData']:",
        "detail": "api.fetch_missing_odds",
        "documentation": {}
    },
    {
        "label": "league_sports_types_mapping",
        "kind": 5,
        "importPath": "api.fetch_missing_odds",
        "description": "api.fetch_missing_odds",
        "peekOfCode": "league_sports_types_mapping = {\n    'English Premier League': 'soccer_epl',\n    'American Major League Soccer': 'soccer_usa_mls',\n    'NFL': 'americanfootball_nfl',\n    'MLB': 'baseball_mlb',\n    'NBA': 'basketball_nba',\n}\n# Setup basic configuration for logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"",
        "detail": "api.fetch_missing_odds",
        "documentation": {}
    },
    {
        "label": "get_reduced_odds",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def get_reduced_odds(all_odds):\n    reduced_odds = []\n    avg_pinnacle_vig = db.get_average_pinnacle()\n    logging.info(f\"avg_pinnacle_vig=============={avg_pinnacle_vig}\")\n    try:\n        for odds in all_odds:\n            api_id = odds[\"id\"]  # Get the odds ID\n            sport_title = league_mapping.get(odds[\"sport_title\"], odds[\"sport_title\"])\n            home_team = mismatch_teams_mapping.get(odds[\"home_team\"], odds[\"home_team\"])\n            away_team = mismatch_teams_mapping.get(odds[\"away_team\"], odds[\"away_team\"])",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "get_reduced_spread_odds",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def get_reduced_spread_odds(all_odds):\n    reduced_odds = []\n    #avg_pinnacle_vig = db.get_average_pinnacle()\n    #logging.info(f\"avg_pinnacle_vig=============={avg_pinnacle_vig}\")\n    try:\n        for odds in all_odds:\n            api_id = odds[\"id\"]  # Get the odds ID\n            sport_title = league_mapping.get(odds[\"sport_title\"], odds[\"sport_title\"])\n            home_team = mismatch_teams_mapping.get(odds[\"home_team\"], odds[\"home_team\"])\n            away_team = mismatch_teams_mapping.get(odds[\"away_team\"], odds[\"away_team\"])",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "fetch_odds",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def fetch_odds():\n    all_odds = []\n    for type in SPORTS_TYPES:\n        api_url = f\"https://api.the-odds-api.com/v4/sports/{type['sport_key']}/odds/\"\n        params = {\n            \"apiKey\": ODDS_API_KEY,\n            \"regions\": type['region'],\n        }\n        response = requests.get(api_url, params=params)\n        if response.status_code == 200:",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "check_if_odds_should_be_stored",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def check_if_odds_should_be_stored(stored_odds, odds, inserting):\n    api_id = odds.get('api_id')\n    home_team_odds = odds.get('home_team_odds')\n    away_team_odds = odds.get('away_team_odds')\n    draw_odds = odds.get('draw_odds')\n    commence_time = odds.get('commence_time')\n    current_utc_time = datetime.now(timezone.utc)\n    current_utc_time = current_utc_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n    # Use a generator expression to find the first matching odds\n    matched_odds = next((item for item in stored_odds if item['oddsapiMatchId'] == api_id), None)",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "create_match__odds_id",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def create_match__odds_id():\n    # generate a unique uuid for the match. make sure it does not already exist.\n    match_odds_id = db.generate_uuid()\n    while db.match_odds_id_exists(match_odds_id):\n        print(f\"Match Odds Table ID {match_odds_id} already exists. Generating a new one.\")\n        match_odds_id = db.generate_uuid()\n    return match_odds_id\ndef store_match_odds(all_odds, stored_odds, inserting = True):\n    match_odds_data = []\n    odds_to_store = []",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "store_match_odds",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def store_match_odds(all_odds, stored_odds, inserting = True):\n    match_odds_data = []\n    odds_to_store = []\n    try:\n        for odds in all_odds:\n            match_odds_id = db.generate_uuid()\n            should_update_match_odds, should_update_odds = check_if_odds_should_be_stored(stored_odds, odds, inserting)  # Get odd for the current match\n            if should_update_match_odds:\n                match_odds_data.append((match_odds_id, odds['api_id'], odds['home_team_odds'], odds['away_team_odds'], odds['draw_odds'], odds['pinnacle_bookmaker'], odds['last_updated']))\n            if should_update_odds:",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "check_if_spread_odds_should_be_stored",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def check_if_spread_odds_should_be_stored(stored_odds, odds, inserting):\n    api_id = odds.get('api_id')\n    home_team_odds = odds.get('home_team_spread_odds')\n    away_team_odds = odds.get('away_team_spread_odds')\n    commence_time = odds.get('commence_time')\n    current_utc_time = datetime.now(timezone.utc)\n    current_utc_time = current_utc_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n    # Use a generator expression to find the first matching odds\n    matched_odds = next((item for item in stored_odds if item['oddsapiMatchId'] == api_id), None)\n    if matched_odds:",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "store_match_spread_odds",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def store_match_spread_odds(all_odds, stored_odds, inserting = True):\n    match_odds_data = []\n    odds_to_store = []\n    try:\n        for odds in all_odds:\n            match_odds_id = db.generate_uuid()\n            should_update_match_odds, should_update_odds = check_if_spread_odds_should_be_stored(stored_odds, odds, inserting)  # Get odd for the current match\n            if should_update_match_odds:\n                match_odds_data.append((match_odds_id, odds['api_id'], odds['home_team_spread_odds'], odds['away_team_spread_odds'], odds['pinnacle_bookmaker'], odds['last_updated']))\n            if should_update_odds:",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "fetch_and_store_match_odds",
        "kind": 2,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "def fetch_and_store_match_odds():\n    logging.info(f\"=============Starting to fetch and store match odds=============\")\n    all_odds = fetch_odds()\n    stored_odds = db.get_stored_odds()\n    store_match_odds(all_odds, stored_odds, False)\nif __name__ == \"__main__\":\n    db.setup_match_odds_table()\n    # Schedule the function to run every 4 minutes\n    schedule.every(4).minutes.do(fetch_and_store_match_odds)\n    # Initial fetch and store to ensure setup is correct",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "SPORTS_TYPES",
        "kind": 5,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "SPORTS_TYPES = [\n    {\n        'sport_key': 'baseball_mlb',\n        'region': 'us,eu',\n    },\n    {\n        'sport_key': 'americanfootball_nfl',\n        'region': 'us,eu'\n    },\n    {",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "league_mapping",
        "kind": 5,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "league_mapping = {\n    'EPL': 'English Premier League',\n    'MLS': 'American Major League Soccer',\n    'MLB': 'MLB',\n    'NFL': 'NFL',\n    'NBA': 'NBA',\n}\n# odds api : thesportsdb\nmismatch_teams_mapping = {\n    'Orlando City SC': 'Orlando City',",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "mismatch_teams_mapping",
        "kind": 5,
        "importPath": "api.fetch_odds",
        "description": "api.fetch_odds",
        "peekOfCode": "mismatch_teams_mapping = {\n    'Orlando City SC': 'Orlando City',\n    'Inter Miami CF': 'Inter Miami',\n    'Atlanta United FC': 'Atlanta United',\n    'CF Montreal': 'CF Montréal',\n    'D.C. United': 'DC United',\n    'Tottenham Hotspur': 'Tottenham',\n    'Columbus Crew SC': 'Columbus Crew',\n    'Minnesota United FC': 'Minnesota United',\n    'Vancouver Whitecaps FC': 'Vancouver Whitecaps',",
        "detail": "api.fetch_odds",
        "documentation": {}
    },
    {
        "label": "fetch_historical_tipoff_odds",
        "kind": 2,
        "importPath": "api.fetch_tipoff_odds",
        "description": "api.fetch_tipoff_odds",
        "peekOfCode": "def fetch_historical_tipoff_odds():\n    #league = \"MLB\"\n    #start_date = \"2025-03-27 00:00:00\"\n    #end_date = None\n    #league = \"English Premier League\"\n    #start_date = \"2024-08-16 00:00:00\"\n    #end_date = None\n    league = \"NBA\"\n    start_date = \"2024-10-21 00:00:00\"\n    end_date = None",
        "detail": "api.fetch_tipoff_odds",
        "documentation": {}
    },
    {
        "label": "fetch_odds",
        "kind": 2,
        "importPath": "api.fetch_tipoff_odds",
        "description": "api.fetch_tipoff_odds",
        "peekOfCode": "def fetch_odds(api_url, event_id, start, do_h2h=True, do_spread=True):\n    # Initialize the current interval index\n    current_index = 0\n    markets = []\n    if do_h2h:\n        markets.append(\"h2h\")\n    if do_spread:\n        markets.append(\"spreads\")\n    if not markets:\n        logging.error(\"No markets specified for fetching odds.\")",
        "detail": "api.fetch_tipoff_odds",
        "documentation": {}
    },
    {
        "label": "fetch_tipoff_odds",
        "kind": 2,
        "importPath": "api.fetch_tipoff_odds",
        "description": "api.fetch_tipoff_odds",
        "peekOfCode": "def fetch_tipoff_odds():\n    live_matches = db.get_live_matches()\n    if not live_matches:\n        logging.info(\"No live matches found. Skipping fetching tip off odds.\")\n        return\n    logging.info(f\"Fetching tip off odds for {len(live_matches)} live matches\")\n    for match in live_matches:\n        matchDate = match['matchDate']\n        matchLeague = match['matchLeague']\n        oddsapiMatchId = match['oddsapiMatchId']",
        "detail": "api.fetch_tipoff_odds",
        "documentation": {}
    },
    {
        "label": "league_sports_types_mapping",
        "kind": 5,
        "importPath": "api.fetch_tipoff_odds",
        "description": "api.fetch_tipoff_odds",
        "peekOfCode": "league_sports_types_mapping = {\n    'English Premier League': 'soccer_epl',\n    'American Major League Soccer': 'soccer_usa_mls',\n    'NFL': 'americanfootball_nfl',\n    'MLB': 'baseball_mlb',\n    'NBA': 'basketball_nba',\n}\n# Setup basic configuration for logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"",
        "detail": "api.fetch_tipoff_odds",
        "documentation": {}
    },
    {
        "label": "get_hotkey",
        "kind": 2,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "def get_hotkey(credentials: Optional[HTTPBasicCredentials] = Depends(security)) -> Optional[str]:\n    if not credentials:\n        return None\n    keypair = Keypair(ss58_address=credentials.username)\n    if keypair.verify(credentials.username, credentials.password):\n        return credentials.username\n    return None\ndef authenticate_with_bittensor(hotkey, metagraph):\n    if hotkey not in metagraph.hotkeys:\n        print(f\"Hotkey not found in metagraph.\")",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "authenticate_with_bittensor",
        "kind": 2,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "def authenticate_with_bittensor(hotkey, metagraph):\n    if hotkey not in metagraph.hotkeys:\n        print(f\"Hotkey not found in metagraph.\")\n        return False\n    uid = metagraph.hotkeys.index(hotkey)\n    if not metagraph.validator_permit[uid] and NETWORK != \"test\":\n        print(\"Bittensor validator permit required\")\n        return False\n    if metagraph.S[uid] < 1000 and NETWORK != \"test\":\n        print(\"Bittensor validator requires 1000+ staked TAO\")",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "app = FastAPI()\n# define the APIKeyHeader for API authorization to our APP endpoints\napi_key_header = APIKeyHeader(name=\"ST_API_KEY\", auto_error=False)\nsecurity = HTTPBasic()\n# Cache configuration\nMATCHES_CACHE_TTL = 300  # 5 minutes\n# Setup basic configuration for logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "api_key_header",
        "kind": 5,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "api_key_header = APIKeyHeader(name=\"ST_API_KEY\", auto_error=False)\nsecurity = HTTPBasic()\n# Cache configuration\nMATCHES_CACHE_TTL = 300  # 5 minutes\n# Setup basic configuration for logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nasync def get_api_key(api_key_header: Optional[str] = Security(api_key_header)) -> Optional[str]:\n    if api_key_header is not None and api_key_header in API_KEYS:",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "security",
        "kind": 5,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "security = HTTPBasic()\n# Cache configuration\nMATCHES_CACHE_TTL = 300  # 5 minutes\n# Setup basic configuration for logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nasync def get_api_key(api_key_header: Optional[str] = Security(api_key_header)) -> Optional[str]:\n    if api_key_header is not None and api_key_header in API_KEYS:\n        return api_key_header",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "MATCHES_CACHE_TTL",
        "kind": 5,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "MATCHES_CACHE_TTL = 300  # 5 minutes\n# Setup basic configuration for logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nasync def get_api_key(api_key_header: Optional[str] = Security(api_key_header)) -> Optional[str]:\n    if api_key_header is not None and api_key_header in API_KEYS:\n        return api_key_header\n    return None\ndef get_hotkey(credentials: Optional[HTTPBasicCredentials] = Depends(security)) -> Optional[str]:",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "get_uids",
        "kind": 2,
        "importPath": "api.snapshot",
        "description": "api.snapshot",
        "peekOfCode": "def get_uids(\n    metagraph: bittensor.metagraph,\n    exclude: typing.List[int] = None\n) -> typing.List[int]:\n    \"\"\"Returns k available random uids from the metagraph.\n    Args:\n        exclude (List[int]): List of uids to exclude from the random sampling.\n    Returns:\n        uids (List[int]): Available uids.\n    \"\"\"",
        "detail": "api.snapshot",
        "documentation": {}
    },
    {
        "label": "take_snapshot",
        "kind": 2,
        "importPath": "api.snapshot",
        "description": "api.snapshot",
        "peekOfCode": "def take_snapshot():\n    # attempt to connect to metagraph 3 times before quitting\n    attempts = 3\n    for attempt in range(attempts):\n        try:\n            subtensor = bittensor.subtensor(network=NETWORK)\n            metagraph: bittensor.metagraph = subtensor.metagraph(NETUID)\n            break  # Exit the loop if successful\n        except Exception as e:\n            logging.error(f\"Attempt {attempt + 1} failed: {e}\")",
        "detail": "api.snapshot",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "api.snapshot",
        "description": "api.snapshot",
        "peekOfCode": "def main():\n    try:\n        # Take a snapshot of the current data\n        result = take_snapshot()\n        if result:\n            print(\"Snapshot taken successfully\")\n        else:\n            print(\"Failed to take snapshot\")\n    except Error as e:\n        print(f\"Error: {e}\")",
        "detail": "api.snapshot",
        "documentation": {}
    },
    {
        "label": "generate_api_key",
        "kind": 2,
        "importPath": "api._generate_api_key",
        "description": "api._generate_api_key",
        "peekOfCode": "def generate_api_key():\n    return secrets.token_urlsafe(32)  # Generates a 32-byte (256-bit) key\nnew_api_key = generate_api_key()\nprint(new_api_key)",
        "detail": "api._generate_api_key",
        "documentation": {}
    },
    {
        "label": "new_api_key",
        "kind": 5,
        "importPath": "api._generate_api_key",
        "description": "api._generate_api_key",
        "peekOfCode": "new_api_key = generate_api_key()\nprint(new_api_key)",
        "detail": "api._generate_api_key",
        "documentation": {}
    },
    {
        "label": "is_cuda_available",
        "kind": 2,
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "peekOfCode": "def is_cuda_available():\n    try:\n        output = subprocess.check_output(\n            [\"nvidia-smi\", \"-L\"], stderr=subprocess.STDOUT\n        )\n        if \"NVIDIA\" in output.decode(\"utf-8\"):\n            return \"cuda\"\n    except Exception:\n        pass\n    try:",
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "check_config",
        "kind": 2,
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "peekOfCode": "def check_config(cls, config: \"bt.Config\"):\n    r\"\"\"Checks/validates the config namespace object.\"\"\"\n    bt.logging.check_config(config)\n    full_path = os.path.expanduser(\n        \"{}/{}/{}/netuid{}/{}\".format(\n            config.logging.logging_dir,  # TODO: change from ~/.bittensor/miners to ~/.bittensor/neurons\n            config.wallet.name,\n            config.wallet.hotkey,\n            config.netuid,\n            config.neuron.name,",
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "add_args",
        "kind": 2,
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "peekOfCode": "def add_args(cls, parser):\n    \"\"\"\n    Adds relevant arguments to the parser for operation.\n    \"\"\"\n    parser.add_argument(\"--netuid\", type=int, help=\"Subnet netuid\", default=1)\n    parser.add_argument(\n        \"--neuron.device\",\n        type=str,\n        help=\"Device to run on.\",\n        default=is_cuda_available(),",
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "add_miner_args",
        "kind": 2,
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "peekOfCode": "def add_miner_args(cls, parser):\n    \"\"\"Add miner specific arguments to the parser.\"\"\"\n    parser.add_argument(\n        \"--neuron.name\",\n        type=str,\n        help=\"Trials for this neuron go in neuron.root / (wallet_cold - wallet_hot) / neuron.name. \",\n        default=\"miner\",\n    )\n    parser.add_argument(\n        \"--blacklist.force_validator_permit\",",
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "add_validator_args",
        "kind": 2,
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "peekOfCode": "def add_validator_args(cls, parser):\n    \"\"\"Add validator specific arguments to the parser.\"\"\"\n    parser.add_argument(\n        \"--neuron.name\",\n        type=str,\n        help=\"Trials for this neuron go in neuron.root / (wallet_cold - wallet_hot) / neuron.name. \",\n        default=\"validator\",\n    )\n    parser.add_argument(\n        \"--neuron.timeout\",",
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 2,
        "importPath": "base.utils.config",
        "description": "base.utils.config",
        "peekOfCode": "def config(cls):\n    \"\"\"\n    Returns the configuration object specific to this miner or validator after adding relevant arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    bt.wallet.add_args(parser)\n    bt.subtensor.add_args(parser)\n    bt.logging.add_args(parser)\n    bt.axon.add_args(parser)\n    cls.add_args(parser)",
        "detail": "base.utils.config",
        "documentation": {}
    },
    {
        "label": "setup_events_logger",
        "kind": 2,
        "importPath": "base.utils.logging",
        "description": "base.utils.logging",
        "peekOfCode": "def setup_events_logger(full_path, events_retention_size):\n    logging.addLevelName(EVENTS_LEVEL_NUM, \"EVENT\")\n    logger = logging.getLogger(\"event\")\n    logger.setLevel(EVENTS_LEVEL_NUM)\n    def event(self, message, *args, **kws):\n        if self.isEnabledFor(EVENTS_LEVEL_NUM):\n            self._log(EVENTS_LEVEL_NUM, message, args, **kws)\n    logging.Logger.event = event\n    formatter = logging.Formatter(\n        \"%(asctime)s | %(levelname)s | %(message)s\",",
        "detail": "base.utils.logging",
        "documentation": {}
    },
    {
        "label": "EVENTS_LEVEL_NUM",
        "kind": 5,
        "importPath": "base.utils.logging",
        "description": "base.utils.logging",
        "peekOfCode": "EVENTS_LEVEL_NUM = 38\nDEFAULT_LOG_BACKUP_COUNT = 10\ndef setup_events_logger(full_path, events_retention_size):\n    logging.addLevelName(EVENTS_LEVEL_NUM, \"EVENT\")\n    logger = logging.getLogger(\"event\")\n    logger.setLevel(EVENTS_LEVEL_NUM)\n    def event(self, message, *args, **kws):\n        if self.isEnabledFor(EVENTS_LEVEL_NUM):\n            self._log(EVENTS_LEVEL_NUM, message, args, **kws)\n    logging.Logger.event = event",
        "detail": "base.utils.logging",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LOG_BACKUP_COUNT",
        "kind": 5,
        "importPath": "base.utils.logging",
        "description": "base.utils.logging",
        "peekOfCode": "DEFAULT_LOG_BACKUP_COUNT = 10\ndef setup_events_logger(full_path, events_retention_size):\n    logging.addLevelName(EVENTS_LEVEL_NUM, \"EVENT\")\n    logger = logging.getLogger(\"event\")\n    logger.setLevel(EVENTS_LEVEL_NUM)\n    def event(self, message, *args, **kws):\n        if self.isEnabledFor(EVENTS_LEVEL_NUM):\n            self._log(EVENTS_LEVEL_NUM, message, args, **kws)\n    logging.Logger.event = event\n    formatter = logging.Formatter(",
        "detail": "base.utils.logging",
        "documentation": {}
    },
    {
        "label": "ttl_cache",
        "kind": 2,
        "importPath": "base.utils.misc",
        "description": "base.utils.misc",
        "peekOfCode": "def ttl_cache(maxsize: int = 128, typed: bool = False, ttl: int = -1):\n    \"\"\"\n    Decorator that creates a cache of the most recently used function calls with a time-to-live (TTL) feature.\n    The cache evicts the least recently used entries if the cache exceeds the `maxsize` or if an entry has\n    been in the cache longer than the `ttl` period.\n    Args:\n        maxsize (int): Maximum size of the cache. Once the cache grows to this size, subsequent entries\n                       replace the least recently used ones. Defaults to 128.\n        typed (bool): If set to True, arguments of different types will be cached separately. For example,\n                      f(3) and f(3.0) will be treated as distinct calls with distinct results. Defaults to False.",
        "detail": "base.utils.misc",
        "documentation": {}
    },
    {
        "label": "ttl_get_block",
        "kind": 2,
        "importPath": "base.utils.misc",
        "description": "base.utils.misc",
        "peekOfCode": "def ttl_get_block(self) -> int:\n    \"\"\"\n    Retrieves the current block number from the blockchain. This method is cached with a time-to-live (TTL)\n    of 12 seconds, meaning that it will only refresh the block number from the blockchain at most every 12 seconds,\n    reducing the number of calls to the underlying blockchain interface.\n    Returns:\n        int: The current block number on the blockchain.\n    This method is useful for applications that need to access the current block number frequently and can\n    tolerate a delay of up to 12 seconds for the latest information. By using a cache with TTL, the method\n    efficiently reduces the workload on the blockchain interface.",
        "detail": "base.utils.misc",
        "documentation": {}
    },
    {
        "label": "check_uid_availability",
        "kind": 2,
        "importPath": "base.utils.uids",
        "description": "base.utils.uids",
        "peekOfCode": "def check_uid_availability(\n    metagraph: \"bt.metagraph.Metagraph\", uid: int, vpermit_tao_limit: int\n) -> bool:\n    \"\"\"Check if uid is available. The UID should be available if it is serving and has less than vpermit_tao_limit stake\n    Args:\n        metagraph (:obj: bt.metagraph.Metagraph): Metagraph object\n        uid (int): uid to be checked\n        vpermit_tao_limit (int): Validator permit tao limit\n    Returns:\n        bool: True if uid is available, False otherwise",
        "detail": "base.utils.uids",
        "documentation": {}
    },
    {
        "label": "get_random_uids",
        "kind": 2,
        "importPath": "base.utils.uids",
        "description": "base.utils.uids",
        "peekOfCode": "def get_random_uids(self, k: int, exclude: List[int] = None) -> np.ndarray:\n    \"\"\"Returns k available random uids from the metagraph.\n    Args:\n        k (int): Number of uids to return.\n        exclude (List[int]): List of uids to exclude from the random sampling.\n    Returns:\n        uids (np.ndarray): Randomly sampled available uids.\n    Notes:\n        If `k` is larger than the number of available `uids`, set `k` to the number of available `uids`.\n    \"\"\"",
        "detail": "base.utils.uids",
        "documentation": {}
    },
    {
        "label": "BaseMinerNeuron",
        "kind": 6,
        "importPath": "base.miner",
        "description": "base.miner",
        "peekOfCode": "class BaseMinerNeuron(BaseNeuron):\n    \"\"\"\n    Base class for Bittensor miners.\n    \"\"\"\n    neuron_type: str = \"MinerNeuron\"\n    @classmethod\n    def add_args(cls, parser: argparse.ArgumentParser):\n        super().add_args(parser)\n        add_miner_args(cls, parser)\n    def __init__(self, config=None):",
        "detail": "base.miner",
        "documentation": {}
    },
    {
        "label": "MockSubtensor",
        "kind": 6,
        "importPath": "base.mock",
        "description": "base.mock",
        "peekOfCode": "class MockSubtensor(bt.MockSubtensor):\n    def __init__(self, netuid, n=16, wallet=None, network=\"mock\"):\n        super().__init__(network=network)\n        if not self.subnet_exists(netuid):\n            self.create_subnet(netuid)\n        # Register ourself (the validator) as a neuron at uid=0\n        if wallet is not None:\n            self.force_register_neuron(\n                netuid=netuid,\n                hotkey=wallet.hotkey.ss58_address,",
        "detail": "base.mock",
        "documentation": {}
    },
    {
        "label": "MockMetagraph",
        "kind": 6,
        "importPath": "base.mock",
        "description": "base.mock",
        "peekOfCode": "class MockMetagraph(bt.metagraph):\n    def __init__(self, netuid=1, network=\"mock\", subtensor=None):\n        super().__init__(netuid=netuid, network=network, sync=False)\n        if subtensor is not None:\n            self.subtensor = subtensor\n        self.sync(subtensor=subtensor)\n        for axon in self.axons:\n            axon.ip = \"127.0.0.0\"\n            axon.port = 8091\n        bt.logging.info(f\"Metagraph: {self}\")",
        "detail": "base.mock",
        "documentation": {}
    },
    {
        "label": "MockDendrite",
        "kind": 6,
        "importPath": "base.mock",
        "description": "base.mock",
        "peekOfCode": "class MockDendrite(bt.dendrite):\n    \"\"\"\n    Replaces a real bittensor network request with a mock request that just returns some static response for all axons that are passed and adds some random delay.\n    \"\"\"\n    def __init__(self, wallet):\n        super().__init__(wallet)\n    async def forward(\n        self,\n        axons: List[bt.axon],\n        synapse: bt.Synapse = bt.Synapse(),",
        "detail": "base.mock",
        "documentation": {}
    },
    {
        "label": "BaseNeuron",
        "kind": 6,
        "importPath": "base.neuron",
        "description": "base.neuron",
        "peekOfCode": "class BaseNeuron(ABC):\n    \"\"\"\n    Base class for Bittensor miners. This class is abstract and should be inherited by a subclass. It contains the core logic for all neurons; validators and miners.\n    In addition to creating a wallet, subtensor, and metagraph, this class also handles the synchronization of the network state via a basic checkpointing mechanism based on epoch length.\n    \"\"\"\n    neuron_type: str = \"BaseNeuron\"\n    @classmethod\n    def check_config(cls, config: \"bt.Config\"):\n        check_config(cls, config)\n    @classmethod",
        "detail": "base.neuron",
        "documentation": {}
    },
    {
        "label": "BaseValidatorNeuron",
        "kind": 6,
        "importPath": "base.validator",
        "description": "base.validator",
        "peekOfCode": "class BaseValidatorNeuron(BaseNeuron):\n    \"\"\"\n    Base class for Bittensor validators. Your validator should inherit from this class.\n    \"\"\"\n    neuron_type: str = \"ValidatorNeuron\"\n    @classmethod\n    def add_args(cls, parser: argparse.ArgumentParser):\n        super().add_args(parser)\n        add_validator_args(cls, parser)\n    def __init__(self, config=None):",
        "detail": "base.validator",
        "documentation": {}
    },
    {
        "label": "IS_DEV",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "IS_DEV = False\n# Controls if validators should process our SportsTensor App-based logic\nENABLE_APP = False\n# The current protocol version (int)\nPROTOCOL_VERSION = 1\n# Interval in minutes that we sync match data\nDATA_SYNC_INTERVAL_IN_MINUTES = 30\n# Interval in minutes that we ask for league commitments from miners\nLEAGUE_COMMITMENT_INTERVAL_IN_MINUTES = 15\n# Interval in minutes that we poll the api for prediction requests from the app",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ENABLE_APP",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "ENABLE_APP = False\n# The current protocol version (int)\nPROTOCOL_VERSION = 1\n# Interval in minutes that we sync match data\nDATA_SYNC_INTERVAL_IN_MINUTES = 30\n# Interval in minutes that we ask for league commitments from miners\nLEAGUE_COMMITMENT_INTERVAL_IN_MINUTES = 15\n# Interval in minutes that we poll the api for prediction requests from the app\nAPP_DATA_SYNC_INTERVAL_IN_MINUTES = 1\n# Interval in minutes that we give validators to respond to an assigned app prediction request",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PROTOCOL_VERSION",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "PROTOCOL_VERSION = 1\n# Interval in minutes that we sync match data\nDATA_SYNC_INTERVAL_IN_MINUTES = 30\n# Interval in minutes that we ask for league commitments from miners\nLEAGUE_COMMITMENT_INTERVAL_IN_MINUTES = 15\n# Interval in minutes that we poll the api for prediction requests from the app\nAPP_DATA_SYNC_INTERVAL_IN_MINUTES = 1\n# Interval in minutes that we give validators to respond to an assigned app prediction request\nAPP_PREDICTIONS_UNFULFILLED_THRESHOLD = 3\n# Validator enforced miner response timeout in seconds",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "DATA_SYNC_INTERVAL_IN_MINUTES",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "DATA_SYNC_INTERVAL_IN_MINUTES = 30\n# Interval in minutes that we ask for league commitments from miners\nLEAGUE_COMMITMENT_INTERVAL_IN_MINUTES = 15\n# Interval in minutes that we poll the api for prediction requests from the app\nAPP_DATA_SYNC_INTERVAL_IN_MINUTES = 1\n# Interval in minutes that we give validators to respond to an assigned app prediction request\nAPP_PREDICTIONS_UNFULFILLED_THRESHOLD = 3\n# Validator enforced miner response timeout in seconds\nVALIDATOR_TIMEOUT = 15\n# Have Validators pull match data every X seconds.",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_COMMITMENT_INTERVAL_IN_MINUTES",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "LEAGUE_COMMITMENT_INTERVAL_IN_MINUTES = 15\n# Interval in minutes that we poll the api for prediction requests from the app\nAPP_DATA_SYNC_INTERVAL_IN_MINUTES = 1\n# Interval in minutes that we give validators to respond to an assigned app prediction request\nAPP_PREDICTIONS_UNFULFILLED_THRESHOLD = 3\n# Validator enforced miner response timeout in seconds\nVALIDATOR_TIMEOUT = 15\n# Have Validators pull match data every X seconds.\nVALI_REFRESH_MATCHES = 60 * 30\n# Have Validators run the cleaning process every X minutes.",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "APP_DATA_SYNC_INTERVAL_IN_MINUTES",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "APP_DATA_SYNC_INTERVAL_IN_MINUTES = 1\n# Interval in minutes that we give validators to respond to an assigned app prediction request\nAPP_PREDICTIONS_UNFULFILLED_THRESHOLD = 3\n# Validator enforced miner response timeout in seconds\nVALIDATOR_TIMEOUT = 15\n# Have Validators pull match data every X seconds.\nVALI_REFRESH_MATCHES = 60 * 30\n# Have Validators run the cleaning process every X minutes.\nPURGE_DEREGGED_MINERS_INTERVAL_IN_MINUTES = 5\n# Minimum time in seconds predictions are allowed before match begins",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "APP_PREDICTIONS_UNFULFILLED_THRESHOLD",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "APP_PREDICTIONS_UNFULFILLED_THRESHOLD = 3\n# Validator enforced miner response timeout in seconds\nVALIDATOR_TIMEOUT = 15\n# Have Validators pull match data every X seconds.\nVALI_REFRESH_MATCHES = 60 * 30\n# Have Validators run the cleaning process every X minutes.\nPURGE_DEREGGED_MINERS_INTERVAL_IN_MINUTES = 5\n# Minimum time in seconds predictions are allowed before match begins\nMIN_PREDICTION_TIME_THRESHOLD = 60 * 5\n# Max number of days in the future for allowable predictions. ",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "VALIDATOR_TIMEOUT",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "VALIDATOR_TIMEOUT = 15\n# Have Validators pull match data every X seconds.\nVALI_REFRESH_MATCHES = 60 * 30\n# Have Validators run the cleaning process every X minutes.\nPURGE_DEREGGED_MINERS_INTERVAL_IN_MINUTES = 5\n# Minimum time in seconds predictions are allowed before match begins\nMIN_PREDICTION_TIME_THRESHOLD = 60 * 5\n# Max number of days in the future for allowable predictions. \nMAX_PREDICTION_DAYS_THRESHOLD = 1\n# Max number of predictions that can be scored at a time",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "VALI_REFRESH_MATCHES",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "VALI_REFRESH_MATCHES = 60 * 30\n# Have Validators run the cleaning process every X minutes.\nPURGE_DEREGGED_MINERS_INTERVAL_IN_MINUTES = 5\n# Minimum time in seconds predictions are allowed before match begins\nMIN_PREDICTION_TIME_THRESHOLD = 60 * 5\n# Max number of days in the future for allowable predictions. \nMAX_PREDICTION_DAYS_THRESHOLD = 1\n# Max number of predictions that can be scored at a time\nMAX_BATCHSIZE_FOR_SCORING = 500\n# Cut off days to attempt to score predictions. i.e. Any predictions not scored with X days will be left behind",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PURGE_DEREGGED_MINERS_INTERVAL_IN_MINUTES",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "PURGE_DEREGGED_MINERS_INTERVAL_IN_MINUTES = 5\n# Minimum time in seconds predictions are allowed before match begins\nMIN_PREDICTION_TIME_THRESHOLD = 60 * 5\n# Max number of days in the future for allowable predictions. \nMAX_PREDICTION_DAYS_THRESHOLD = 1\n# Max number of predictions that can be scored at a time\nMAX_BATCHSIZE_FOR_SCORING = 500\n# Cut off days to attempt to score predictions. i.e. Any predictions not scored with X days will be left behind\nSCORING_CUTOFF_IN_DAYS = 30\n# Cut off days to attempt to sync match odds. i.e. Any match odds not synced with X days will be left behind",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_PREDICTION_TIME_THRESHOLD",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MIN_PREDICTION_TIME_THRESHOLD = 60 * 5\n# Max number of days in the future for allowable predictions. \nMAX_PREDICTION_DAYS_THRESHOLD = 1\n# Max number of predictions that can be scored at a time\nMAX_BATCHSIZE_FOR_SCORING = 500\n# Cut off days to attempt to score predictions. i.e. Any predictions not scored with X days will be left behind\nSCORING_CUTOFF_IN_DAYS = 30\n# Cut off days to attempt to sync match odds. i.e. Any match odds not synced with X days will be left behind\nMATCH_ODDS_CUTOFF_IN_DAYS = 7\n# Interval in minutes that we attempt to score predictions",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_PREDICTION_DAYS_THRESHOLD",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MAX_PREDICTION_DAYS_THRESHOLD = 1\n# Max number of predictions that can be scored at a time\nMAX_BATCHSIZE_FOR_SCORING = 500\n# Cut off days to attempt to score predictions. i.e. Any predictions not scored with X days will be left behind\nSCORING_CUTOFF_IN_DAYS = 30\n# Cut off days to attempt to sync match odds. i.e. Any match odds not synced with X days will be left behind\nMATCH_ODDS_CUTOFF_IN_DAYS = 7\n# Interval in minutes that we attempt to score predictions\nSCORING_INTERVAL_IN_MINUTES = 1\n# The maximum number of characters a team name can have.",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_BATCHSIZE_FOR_SCORING",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MAX_BATCHSIZE_FOR_SCORING = 500\n# Cut off days to attempt to score predictions. i.e. Any predictions not scored with X days will be left behind\nSCORING_CUTOFF_IN_DAYS = 30\n# Cut off days to attempt to sync match odds. i.e. Any match odds not synced with X days will be left behind\nMATCH_ODDS_CUTOFF_IN_DAYS = 7\n# Interval in minutes that we attempt to score predictions\nSCORING_INTERVAL_IN_MINUTES = 1\n# The maximum number of characters a team name can have.\nMAX_TEAM_NAME_LENGTH = 32\n########## SCORING CONSTANTS ##############",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SCORING_CUTOFF_IN_DAYS",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "SCORING_CUTOFF_IN_DAYS = 30\n# Cut off days to attempt to sync match odds. i.e. Any match odds not synced with X days will be left behind\nMATCH_ODDS_CUTOFF_IN_DAYS = 7\n# Interval in minutes that we attempt to score predictions\nSCORING_INTERVAL_IN_MINUTES = 1\n# The maximum number of characters a team name can have.\nMAX_TEAM_NAME_LENGTH = 32\n########## SCORING CONSTANTS ##############\nNO_LEAGUE_COMMITMENT_PENALTY = -0.1\nNO_LEAGUE_COMMITMENT_GRACE_PERIOD = 60 * 60 * 24 # 24 hours",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MATCH_ODDS_CUTOFF_IN_DAYS",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MATCH_ODDS_CUTOFF_IN_DAYS = 7\n# Interval in minutes that we attempt to score predictions\nSCORING_INTERVAL_IN_MINUTES = 1\n# The maximum number of characters a team name can have.\nMAX_TEAM_NAME_LENGTH = 32\n########## SCORING CONSTANTS ##############\nNO_LEAGUE_COMMITMENT_PENALTY = -0.1\nNO_LEAGUE_COMMITMENT_GRACE_PERIOD = 60 * 60 * 24 # 24 hours\nMIN_MINER_RELIABILITY = 0.75\nMINER_RELIABILITY_CUTOFF_IN_DAYS = 4",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SCORING_INTERVAL_IN_MINUTES",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "SCORING_INTERVAL_IN_MINUTES = 1\n# The maximum number of characters a team name can have.\nMAX_TEAM_NAME_LENGTH = 32\n########## SCORING CONSTANTS ##############\nNO_LEAGUE_COMMITMENT_PENALTY = -0.1\nNO_LEAGUE_COMMITMENT_GRACE_PERIOD = 60 * 60 * 24 # 24 hours\nMIN_MINER_RELIABILITY = 0.75\nMINER_RELIABILITY_CUTOFF_IN_DAYS = 4\nMAX_GFILTER_FOR_WRONG_PREDICTION = 0.5\nMIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION = 1.0",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_TEAM_NAME_LENGTH",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MAX_TEAM_NAME_LENGTH = 32\n########## SCORING CONSTANTS ##############\nNO_LEAGUE_COMMITMENT_PENALTY = -0.1\nNO_LEAGUE_COMMITMENT_GRACE_PERIOD = 60 * 60 * 24 # 24 hours\nMIN_MINER_RELIABILITY = 0.75\nMINER_RELIABILITY_CUTOFF_IN_DAYS = 4\nMAX_GFILTER_FOR_WRONG_PREDICTION = 0.5\nMIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION = 1.0\nMIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION = 0.75\nMIN_EDGE_SCORE = -20.0",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "NO_LEAGUE_COMMITMENT_PENALTY",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "NO_LEAGUE_COMMITMENT_PENALTY = -0.1\nNO_LEAGUE_COMMITMENT_GRACE_PERIOD = 60 * 60 * 24 # 24 hours\nMIN_MINER_RELIABILITY = 0.75\nMINER_RELIABILITY_CUTOFF_IN_DAYS = 4\nMAX_GFILTER_FOR_WRONG_PREDICTION = 0.5\nMIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION = 1.0\nMIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION = 0.75\nMIN_EDGE_SCORE = -20.0\nMAX_MIN_EDGE_SCORE = -20.0\n# ROI constants",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "NO_LEAGUE_COMMITMENT_GRACE_PERIOD",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "NO_LEAGUE_COMMITMENT_GRACE_PERIOD = 60 * 60 * 24 # 24 hours\nMIN_MINER_RELIABILITY = 0.75\nMINER_RELIABILITY_CUTOFF_IN_DAYS = 4\nMAX_GFILTER_FOR_WRONG_PREDICTION = 0.5\nMIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION = 1.0\nMIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION = 0.75\nMIN_EDGE_SCORE = -20.0\nMAX_MIN_EDGE_SCORE = -20.0\n# ROI constants\nROI_BET_AMOUNT = 1",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_MINER_RELIABILITY",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MIN_MINER_RELIABILITY = 0.75\nMINER_RELIABILITY_CUTOFF_IN_DAYS = 4\nMAX_GFILTER_FOR_WRONG_PREDICTION = 0.5\nMIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION = 1.0\nMIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION = 0.75\nMIN_EDGE_SCORE = -20.0\nMAX_MIN_EDGE_SCORE = -20.0\n# ROI constants\nROI_BET_AMOUNT = 1\nROI_INCR_PRED_COUNT_PERCENTAGE = 0.05",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MINER_RELIABILITY_CUTOFF_IN_DAYS",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MINER_RELIABILITY_CUTOFF_IN_DAYS = 4\nMAX_GFILTER_FOR_WRONG_PREDICTION = 0.5\nMIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION = 1.0\nMIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION = 0.75\nMIN_EDGE_SCORE = -20.0\nMAX_MIN_EDGE_SCORE = -20.0\n# ROI constants\nROI_BET_AMOUNT = 1\nROI_INCR_PRED_COUNT_PERCENTAGE = 0.05\nMAX_INCR_ROI_DIFF_PERCENTAGE = 0.10",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_GFILTER_FOR_WRONG_PREDICTION",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MAX_GFILTER_FOR_WRONG_PREDICTION = 0.5\nMIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION = 1.0\nMIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION = 0.75\nMIN_EDGE_SCORE = -20.0\nMAX_MIN_EDGE_SCORE = -20.0\n# ROI constants\nROI_BET_AMOUNT = 1\nROI_INCR_PRED_COUNT_PERCENTAGE = 0.05\nMAX_INCR_ROI_DIFF_PERCENTAGE = 0.10\nROI_SCORING_WEIGHT = 0.50",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MIN_GFILTER_FOR_CORRECT_UNDERDOG_PREDICTION = 1.0\nMIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION = 0.75\nMIN_EDGE_SCORE = -20.0\nMAX_MIN_EDGE_SCORE = -20.0\n# ROI constants\nROI_BET_AMOUNT = 1\nROI_INCR_PRED_COUNT_PERCENTAGE = 0.05\nMAX_INCR_ROI_DIFF_PERCENTAGE = 0.10\nROI_SCORING_WEIGHT = 0.50\nACTIVE_LEAGUES = [",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MIN_GFILTER_FOR_WRONG_UNDERDOG_PREDICTION = 0.75\nMIN_EDGE_SCORE = -20.0\nMAX_MIN_EDGE_SCORE = -20.0\n# ROI constants\nROI_BET_AMOUNT = 1\nROI_INCR_PRED_COUNT_PERCENTAGE = 0.05\nMAX_INCR_ROI_DIFF_PERCENTAGE = 0.10\nROI_SCORING_WEIGHT = 0.50\nACTIVE_LEAGUES = [\n    League.MLS,",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MIN_EDGE_SCORE",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MIN_EDGE_SCORE = -20.0\nMAX_MIN_EDGE_SCORE = -20.0\n# ROI constants\nROI_BET_AMOUNT = 1\nROI_INCR_PRED_COUNT_PERCENTAGE = 0.05\nMAX_INCR_ROI_DIFF_PERCENTAGE = 0.10\nROI_SCORING_WEIGHT = 0.50\nACTIVE_LEAGUES = [\n    League.MLS,\n    League.NBA,",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_MIN_EDGE_SCORE",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MAX_MIN_EDGE_SCORE = -20.0\n# ROI constants\nROI_BET_AMOUNT = 1\nROI_INCR_PRED_COUNT_PERCENTAGE = 0.05\nMAX_INCR_ROI_DIFF_PERCENTAGE = 0.10\nROI_SCORING_WEIGHT = 0.50\nACTIVE_LEAGUES = [\n    League.MLS,\n    League.NBA,\n    League.MLB",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_BET_AMOUNT",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "ROI_BET_AMOUNT = 1\nROI_INCR_PRED_COUNT_PERCENTAGE = 0.05\nMAX_INCR_ROI_DIFF_PERCENTAGE = 0.10\nROI_SCORING_WEIGHT = 0.50\nACTIVE_LEAGUES = [\n    League.MLS,\n    League.NBA,\n    League.MLB\n]\nLEAGUES_ALLOWING_DRAWS = [",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_INCR_PRED_COUNT_PERCENTAGE",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "ROI_INCR_PRED_COUNT_PERCENTAGE = 0.05\nMAX_INCR_ROI_DIFF_PERCENTAGE = 0.10\nROI_SCORING_WEIGHT = 0.50\nACTIVE_LEAGUES = [\n    League.MLS,\n    League.NBA,\n    League.MLB\n]\nLEAGUES_ALLOWING_DRAWS = [\n    League.EPL,",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "MAX_INCR_ROI_DIFF_PERCENTAGE",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "MAX_INCR_ROI_DIFF_PERCENTAGE = 0.10\nROI_SCORING_WEIGHT = 0.50\nACTIVE_LEAGUES = [\n    League.MLS,\n    League.NBA,\n    League.MLB\n]\nLEAGUES_ALLOWING_DRAWS = [\n    League.EPL,\n    League.MLS",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROI_SCORING_WEIGHT",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "ROI_SCORING_WEIGHT = 0.50\nACTIVE_LEAGUES = [\n    League.MLS,\n    League.NBA,\n    League.MLB\n]\nLEAGUES_ALLOWING_DRAWS = [\n    League.EPL,\n    League.MLS\n]",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ACTIVE_LEAGUES",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "ACTIVE_LEAGUES = [\n    League.MLS,\n    League.NBA,\n    League.MLB\n]\nLEAGUES_ALLOWING_DRAWS = [\n    League.EPL,\n    League.MLS\n]\nROLLING_PREDICTION_THRESHOLD_BY_LEAGUE = {",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUES_ALLOWING_DRAWS",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "LEAGUES_ALLOWING_DRAWS = [\n    League.EPL,\n    League.MLS\n]\nROLLING_PREDICTION_THRESHOLD_BY_LEAGUE = {\n    League.MLB: 1150,\n    League.NBA: 710,\n    League.EPL: 256,\n    League.MLS: 256,\n    League.NFL: 200",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ROLLING_PREDICTION_THRESHOLD_BY_LEAGUE",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "ROLLING_PREDICTION_THRESHOLD_BY_LEAGUE = {\n    League.MLB: 1150,\n    League.NBA: 710,\n    League.EPL: 256,\n    League.MLS: 256,\n    League.NFL: 200\n}\n# MUST ADD UP to 1.0 (100%)\nLEAGUE_SCORING_PERCENTAGES = {\n    League.MLB: 0.85,",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_SCORING_PERCENTAGES",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "LEAGUE_SCORING_PERCENTAGES = {\n    League.MLB: 0.85,\n    League.NBA: 0.05,\n    League.EPL: 0.0,\n    League.MLS: 0.10,\n    League.NFL: 0.0\n}\n# ALPHA controls how many predictions are needed to start getting rewards. Higher the ALPHA, the less predictions needed.\nLEAGUE_SENSITIVITY_ALPHAS = {\n    League.MLB: 0.008,",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_SENSITIVITY_ALPHAS",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "LEAGUE_SENSITIVITY_ALPHAS = {\n    League.MLB: 0.008,\n    League.NBA: 0.013,\n    League.EPL: 0.036,\n    League.MLS: 0.036,\n    League.NFL: 0.046\n}\n# Minimum rho controls how many predictions are needed to start getting rewards. Higher the RHO, the less predictions needed.\nLEAGUE_MINIMUM_RHOS = {\n    League.MLB: 0.00032,",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_MINIMUM_RHOS",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "LEAGUE_MINIMUM_RHOS = {\n    League.MLB: 0.00032,\n    League.NBA: 0.00035,\n    League.EPL: 0.000210,\n    League.MLS: 0.000210,\n    League.NFL: 0.00035\n}\n# Prediction integrity punishment constants\nINTEGRITY_CHOICE_AGREEMENT_THRESHOLD = 0.9\nINTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_LOW = 0.8",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "INTEGRITY_CHOICE_AGREEMENT_THRESHOLD",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "INTEGRITY_CHOICE_AGREEMENT_THRESHOLD = 0.9\nINTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_LOW = 0.8\nINTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_HIGH = 0.9\nINTEGRITY_PROB_CORRELATION_THRESHOLD = 0.9\n# The minimum number of shared predictions a miner pair must have to be considered for prediction integrity analysis.\nLEAGUE_MINIMUM_INTEGRITY_PREDICTIONS = {\n    League.MLB: 400,\n    League.NBA: 300,\n    League.EPL: 100,\n    League.MLS: 100,",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "INTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_LOW",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "INTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_LOW = 0.8\nINTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_HIGH = 0.9\nINTEGRITY_PROB_CORRELATION_THRESHOLD = 0.9\n# The minimum number of shared predictions a miner pair must have to be considered for prediction integrity analysis.\nLEAGUE_MINIMUM_INTEGRITY_PREDICTIONS = {\n    League.MLB: 400,\n    League.NBA: 300,\n    League.EPL: 100,\n    League.MLS: 100,\n    League.NFL: 195,",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "INTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_HIGH",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "INTEGRITY_CHOICE_AGREEMENT_GRADIENT_THRESHOLD_HIGH = 0.9\nINTEGRITY_PROB_CORRELATION_THRESHOLD = 0.9\n# The minimum number of shared predictions a miner pair must have to be considered for prediction integrity analysis.\nLEAGUE_MINIMUM_INTEGRITY_PREDICTIONS = {\n    League.MLB: 400,\n    League.NBA: 300,\n    League.EPL: 100,\n    League.MLS: 100,\n    League.NFL: 195,\n}",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "INTEGRITY_PROB_CORRELATION_THRESHOLD",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "INTEGRITY_PROB_CORRELATION_THRESHOLD = 0.9\n# The minimum number of shared predictions a miner pair must have to be considered for prediction integrity analysis.\nLEAGUE_MINIMUM_INTEGRITY_PREDICTIONS = {\n    League.MLB: 400,\n    League.NBA: 300,\n    League.EPL: 100,\n    League.MLS: 100,\n    League.NFL: 195,\n}\n# Single sensitivity alpha depcrecated for league-specific sensitivity alphas",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "LEAGUE_MINIMUM_INTEGRITY_PREDICTIONS",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "LEAGUE_MINIMUM_INTEGRITY_PREDICTIONS = {\n    League.MLB: 400,\n    League.NBA: 300,\n    League.EPL: 100,\n    League.MLS: 100,\n    League.NFL: 195,\n}\n# Single sensitivity alpha depcrecated for league-specific sensitivity alphas\nSENSITIVITY_ALPHA = 0.025\n# GAMMA controls the time decay of CLV. Higher the GAMMA, the faster the decay.",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "SENSITIVITY_ALPHA",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "SENSITIVITY_ALPHA = 0.025\n# GAMMA controls the time decay of CLV. Higher the GAMMA, the faster the decay.\nGAMMA = 0.00125\n# KAPPA controls the sharpness of the interchange between CLV and Time. Higher the KAPPA, the sharper the interchange.\nTRANSITION_KAPPA = 35\n# BETA controls the ranges that the CLV component lives within. Higher the BETA, the tighter the range.\nEXTREMIS_BETA = 0.25\n# PARETO_MU is the minimum value for the Pareto distribution\nPARETO_MU = 1.0\n# PARETO_ALPHA is the shape of the Pareto distribution. The lower the ALPHA, the more suppressed the distribution.",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "GAMMA",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "GAMMA = 0.00125\n# KAPPA controls the sharpness of the interchange between CLV and Time. Higher the KAPPA, the sharper the interchange.\nTRANSITION_KAPPA = 35\n# BETA controls the ranges that the CLV component lives within. Higher the BETA, the tighter the range.\nEXTREMIS_BETA = 0.25\n# PARETO_MU is the minimum value for the Pareto distribution\nPARETO_MU = 1.0\n# PARETO_ALPHA is the shape of the Pareto distribution. The lower the ALPHA, the more suppressed the distribution.\nPARETO_ALPHA = 1.2\nENABLE_EMISSION_CONTROL = True",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "TRANSITION_KAPPA",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "TRANSITION_KAPPA = 35\n# BETA controls the ranges that the CLV component lives within. Higher the BETA, the tighter the range.\nEXTREMIS_BETA = 0.25\n# PARETO_MU is the minimum value for the Pareto distribution\nPARETO_MU = 1.0\n# PARETO_ALPHA is the shape of the Pareto distribution. The lower the ALPHA, the more suppressed the distribution.\nPARETO_ALPHA = 1.2\nENABLE_EMISSION_CONTROL = True\nEMISSION_CONTROL_UID = 7\nEMISSION_CONTROL_PERC = 0.4",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EXTREMIS_BETA",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "EXTREMIS_BETA = 0.25\n# PARETO_MU is the minimum value for the Pareto distribution\nPARETO_MU = 1.0\n# PARETO_ALPHA is the shape of the Pareto distribution. The lower the ALPHA, the more suppressed the distribution.\nPARETO_ALPHA = 1.2\nENABLE_EMISSION_CONTROL = True\nEMISSION_CONTROL_UID = 7\nEMISSION_CONTROL_PERC = 0.4",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PARETO_MU",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "PARETO_MU = 1.0\n# PARETO_ALPHA is the shape of the Pareto distribution. The lower the ALPHA, the more suppressed the distribution.\nPARETO_ALPHA = 1.2\nENABLE_EMISSION_CONTROL = True\nEMISSION_CONTROL_UID = 7\nEMISSION_CONTROL_PERC = 0.4",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "PARETO_ALPHA",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "PARETO_ALPHA = 1.2\nENABLE_EMISSION_CONTROL = True\nEMISSION_CONTROL_UID = 7\nEMISSION_CONTROL_PERC = 0.4",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "ENABLE_EMISSION_CONTROL",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "ENABLE_EMISSION_CONTROL = True\nEMISSION_CONTROL_UID = 7\nEMISSION_CONTROL_PERC = 0.4",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EMISSION_CONTROL_UID",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "EMISSION_CONTROL_UID = 7\nEMISSION_CONTROL_PERC = 0.4",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "EMISSION_CONTROL_PERC",
        "kind": 5,
        "importPath": "common.constants",
        "description": "common.constants",
        "peekOfCode": "EMISSION_CONTROL_PERC = 0.4",
        "detail": "common.constants",
        "documentation": {}
    },
    {
        "label": "StrictBaseModel",
        "kind": 6,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "class StrictBaseModel(BaseModel):\n    \"\"\"A BaseModel that enforces stricter validation constraints\"\"\"\n    class Config:\n        # JSON serialization doesn't seem to work correctly without\n        # enabling `use_enum_values`. It's possible this isn't an\n        # issue with newer version of pydantic, which we can't use.\n        use_enum_values = True\nclass Sport(IntEnum):\n    \"\"\"The sport a prediction pertains to. This will be expanded over time as we increase the types of sports we predict.\"\"\"\n    SOCCER = 1",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Sport",
        "kind": 6,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "class Sport(IntEnum):\n    \"\"\"The sport a prediction pertains to. This will be expanded over time as we increase the types of sports we predict.\"\"\"\n    SOCCER = 1\n    FOOTBALL = 2\n    BASEBALL = 3\n    BASKETBALL = 4\n    CRICKET = 5\n    # Additional enum values reserved for yet to be implemented sources.\n    UNKNOWN_6 = 6\n    UNKNOWN_7 = 7",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "League",
        "kind": 6,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "class League(Enum):\n    \"\"\"Represents a sports league, mainly used for mapping and indicating active status to run predictions on.\"\"\"\n    MLB = \"MLB\"\n    NFL = \"NFL\"\n    NBA = \"NBA\"\n    NHL = \"NHL\"\n    EPL = \"English Premier League\"\n    MLS = \"American Major League Soccer\"\n    \"\"\"\n    leagueId: PositiveInt = Field(",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Match",
        "kind": 6,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "class Match(StrictBaseModel):\n    \"\"\"Represents a match/game, sport agnostic.\"\"\"\n    matchId: str = Field(info={\"description\": \"Unique ID that represents a match.\"})\n    # The datetime of the starting time of the match. Should be in UTC?\n    matchDate: dt.datetime\n    sport: Sport\n    league: League\n    # Set variable to keep track if the match has completed. Default to False.\n    isComplete: bool = False\n    homeTeamName: str",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "Prediction",
        "kind": 6,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "class Prediction(StrictBaseModel):\n    \"\"\"Represents a base prediction, sport agnostic.\"\"\"\n    predictionId: Optional[PositiveInt] = Field(\n        default=None,\n        description=\"Unique ID that represents a predication.\"\n    )\n    minerId: Optional[NonNegativeInt] = Field(\n        default=None,\n        description=\"Unique ID that represents a miner.\"\n    )",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "ProbabilityChoice",
        "kind": 6,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "class ProbabilityChoice(Enum):\n    \"\"\"Represents the choice a miner can make for a prediction.\"\"\"\n    HOMETEAM = \"HomeTeam\"\n    AWAYTEAM = \"AwayTeam\"\n    DRAW = \"Draw\"\ndef get_probablity_choice_from_string(choice_str: str) -> Optional[ProbabilityChoice]:\n    \"\"\"Utility function to get a ProbabilityChoice enum from a string.\"\"\"\n    for choice in ProbabilityChoice:\n        if choice.value == choice_str:\n            return choice",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPrediction",
        "kind": 6,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "class MatchPrediction(Prediction):\n    \"\"\"Represents a prediction of a sports match.\"\"\"\n    homeTeamName: str\n    awayTeamName: str\n    homeTeamScore: Optional[int] = Field(default=None)\n    awayTeamScore: Optional[int] = Field(default=None)\n    probabilityChoice: Optional[ProbabilityChoice] = Field(default=None)\n    probability: Optional[float] = Field(default=None)\n    closingEdge: Optional[float] = Field(default=None)\n    def get_predicted_team(self) -> str:",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MatchPredictionWithMatchData",
        "kind": 6,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "class MatchPredictionWithMatchData(BaseModel):\n    prediction: MatchPrediction\n    actualHomeTeamScore: int\n    actualAwayTeamScore: int\n    homeTeamOdds: float\n    awayTeamOdds: float\n    drawOdds: float\n    def get_closing_odds_for_predicted_outcome(self) -> Optional[float]:\n        \"\"\"\n        Get the closing odds for the predicted outcome.",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "get_league_from_string",
        "kind": 2,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "def get_league_from_string(league_string: str) -> League:\n    for league in League:\n        if league_string.upper() == league.name or league_string == league.value:\n            return league\n    raise ValueError(f\"Invalid league: {league_string}\")\nclass Match(StrictBaseModel):\n    \"\"\"Represents a match/game, sport agnostic.\"\"\"\n    matchId: str = Field(info={\"description\": \"Unique ID that represents a match.\"})\n    # The datetime of the starting time of the match. Should be in UTC?\n    matchDate: dt.datetime",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "get_probablity_choice_from_string",
        "kind": 2,
        "importPath": "common.data",
        "description": "common.data",
        "peekOfCode": "def get_probablity_choice_from_string(choice_str: str) -> Optional[ProbabilityChoice]:\n    \"\"\"Utility function to get a ProbabilityChoice enum from a string.\"\"\"\n    for choice in ProbabilityChoice:\n        if choice.value == choice_str:\n            return choice\n    return None\nclass MatchPrediction(Prediction):\n    \"\"\"Represents a prediction of a sports match.\"\"\"\n    homeTeamName: str\n    awayTeamName: str",
        "detail": "common.data",
        "documentation": {}
    },
    {
        "label": "MetagraphSyncer",
        "kind": 6,
        "importPath": "common.metagraph_syncer",
        "description": "common.metagraph_syncer",
        "peekOfCode": "class MetagraphSyncer:\n    @dataclasses.dataclass\n    class _State:\n        metagraph: Optional[bt.metagraph] = None\n        last_synced_time: Optional[datetime] = None\n        listeners: List = field(default_factory=list)\n    def __init__(self, subtensor: bt.subtensor, config: Dict[int, int]):\n        \"\"\"Constructs a new MetagraphSyncer, that periodically refreshes metagraph defined in the config.\n        Args:\n            subtensor (bt.subtensor): The subtensor used to fetch the metagraphs.",
        "detail": "common.metagraph_syncer",
        "documentation": {}
    },
    {
        "label": "BaseProtocol",
        "kind": 6,
        "importPath": "common.protocol",
        "description": "common.protocol",
        "peekOfCode": "class BaseProtocol(bt.Synapse):\n    class Config:\n        arbitrary_types_allowed = True\n        validate_assignment = True\n    version: Optional[int] = pydantic.Field(\n        description=\"Protocol version\", default=None\n    )\nclass GetLeagueCommitments(BaseProtocol):\n    \"\"\"\n    Protocol by which Validators can retrieve the leagues that a Miner is committed to.",
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetLeagueCommitments",
        "kind": 6,
        "importPath": "common.protocol",
        "description": "common.protocol",
        "peekOfCode": "class GetLeagueCommitments(BaseProtocol):\n    \"\"\"\n    Protocol by which Validators can retrieve the leagues that a Miner is committed to.\n    Attributes:\n    - leagues: A list of League objects that the Miner is committed to.\n    \"\"\"\n    leagues: List[League] = pydantic.Field(\n        description=\"The list of leagues that the Miner is committed to\",\n        frozen=False,\n        repr=False,",
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "GetMatchPrediction",
        "kind": 6,
        "importPath": "common.protocol",
        "description": "common.protocol",
        "peekOfCode": "class GetMatchPrediction(BaseProtocol):\n    \"\"\"\n    Protocol by which Validators can retrieve a Match Prediction from a Miner.\n    Attributes:\n    - match_predicton: A single MatchPrediction object that the Miner can serve.\n    \"\"\"\n    match_prediction: MatchPrediction = pydantic.Field(\n        description=\"The MatchPrediction object being requested\",\n        frozen=False,\n        repr=False,",
        "detail": "common.protocol",
        "documentation": {}
    },
    {
        "label": "is_miner",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def is_miner(uid: int, metagraph: bt.metagraph) -> bool:\n    \"\"\"Checks if a UID on the subnet is a miner.\"\"\"\n    # Assume everyone who isn't a validator is a miner.\n    # This explicilty disallows validator/miner hybrids.\n    # Explicitly blacklist known bad coldkeys.\n    if metagraph.coldkeys[uid] in [\n        \"5DF9jPcH8hvEoiV217zXD9C2Uad9GVwAM7jbmsM5SMwUFzaS\",\n        \"5CMfxqSmWPyjWy16MPHw117y2VE7MvZ93rf3U6A77xf1trBA\",\n        \"5GbWdBLCzXFd4ZSh8CGPYDRkxy8vcmULbfHE5gZgowxjgzHp\",\n        \"5Di443BWvJKLHnLAkxvzSZUcu4jSE6Ka9UStjEMduwzRsy5b\",",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "is_validator",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def is_validator(uid: int, metagraph: bt.metagraph) -> bool:\n    \"\"\"Checks if a UID on the subnet is a validator.\"\"\"\n    return metagraph.validator_permit[uid] and metagraph.S[uid] >= 10_000\ndef get_miner_uids(metagraph: bt.metagraph, my_uid: int) -> List[int]:\n    \"\"\"Gets the uids of all miners in the metagraph.\"\"\"\n    return sorted(\n        [\n            uid.item()\n            for uid in metagraph.uids\n            if is_miner(uid.item(), metagraph) and uid.item() != my_uid",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "get_miner_uids",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def get_miner_uids(metagraph: bt.metagraph, my_uid: int) -> List[int]:\n    \"\"\"Gets the uids of all miners in the metagraph.\"\"\"\n    return sorted(\n        [\n            uid.item()\n            for uid in metagraph.uids\n            if is_miner(uid.item(), metagraph) and uid.item() != my_uid\n        ]\n    )\ndef get_uid(wallet: bt.wallet, metagraph: bt.metagraph) -> Optional[int]:",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "get_uid",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def get_uid(wallet: bt.wallet, metagraph: bt.metagraph) -> Optional[int]:\n    \"\"\"Gets the uid of the wallet in the metagraph or None if not registered.\"\"\"\n    if wallet.hotkey.ss58_address in metagraph.hotkeys:\n        return metagraph.hotkeys.index(wallet.hotkey.ss58_address)\n    return None\ndef assert_registered(wallet: bt.wallet, metagraph: bt.metagraph):\n    \"\"\"Exits the process if wallet isn't registered in metagraph\"\"\"\n    # --- Check for registration.\n    if wallet.hotkey.ss58_address not in metagraph.hotkeys:\n        bt.logging.error(",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "assert_registered",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def assert_registered(wallet: bt.wallet, metagraph: bt.metagraph):\n    \"\"\"Exits the process if wallet isn't registered in metagraph\"\"\"\n    # --- Check for registration.\n    if wallet.hotkey.ss58_address not in metagraph.hotkeys:\n        bt.logging.error(\n            f\"Wallet: {wallet} is not registered on netuid {metagraph.netuid}.\"\n            f\" Please register the hotkey using `btcli subnets register` before trying again.\"\n        )\n        sys.exit(1)\ndef serialize_to_file(obj: Any, filename: str) -> None:",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "serialize_to_file",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def serialize_to_file(obj: Any, filename: str) -> None:\n    \"\"\"\n    Serializes 'obj' and writes it to 'filename'\n    \"\"\"\n    with open(filename, \"wb\") as file:\n        pickle.dump(obj, file)\ndef deserialize_from_file(filename: str) -> Any:\n    \"\"\"\n    Deserialize an object from a file.\n    \"\"\"",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "deserialize_from_file",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def deserialize_from_file(filename: str) -> Any:\n    \"\"\"\n    Deserialize an object from a file.\n    \"\"\"\n    with open(filename, \"rb\") as file:\n        obj = pickle.load(file)\n    return obj\n# LRU Cache with TTL\ndef ttl_cache(maxsize: int = 128, typed: bool = False, ttl: int = -1):\n    \"\"\"",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "ttl_cache",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def ttl_cache(maxsize: int = 128, typed: bool = False, ttl: int = -1):\n    \"\"\"\n    Decorator that creates a cache of the most recently used function calls with a time-to-live (TTL) feature.\n    The cache evicts the least recently used entries if the cache exceeds the `maxsize` or if an entry has\n    been in the cache longer than the `ttl` period.\n    Args:\n        maxsize (int): Maximum size of the cache. Once the cache grows to this size, subsequent entries\n                       replace the least recently used ones. Defaults to 128.\n        typed (bool): If set to True, arguments of different types will be cached separately. For example,\n                      f(3) and f(3.0) will be treated as distinct calls with distinct results. Defaults to False.",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "ttl_get_block",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def ttl_get_block(self) -> int:\n    \"\"\"\n    Retrieves the current block number from the blockchain. This method is cached with a time-to-live (TTL)\n    of 12 seconds, meaning that it will only refresh the block number from the blockchain at most every 12 seconds,\n    reducing the number of calls to the underlying blockchain interface.\n    Returns:\n        int: The current block number on the blockchain.\n    This method is useful for applications that need to access the current block number frequently and can\n    tolerate a delay of up to 12 seconds for the latest information. By using a cache with TTL, the method\n    efficiently reduces the workload on the blockchain interface.",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "run_in_thread",
        "kind": 2,
        "importPath": "common.utils",
        "description": "common.utils",
        "peekOfCode": "def run_in_thread(func: functools.partial, ttl: int, name=None) -> Any:\n    \"\"\"Runs the provided function on a thread with 'ttl' seconds to complete.\n    Args:\n        func (functools.partial): Function to be run.\n        ttl (int): How long to try for in seconds.\n    Returns:\n        Any: The value returned by 'func'\n    \"\"\"\n    executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)\n    try:",
        "detail": "common.utils",
        "documentation": {}
    },
    {
        "label": "check_config",
        "kind": 2,
        "importPath": "docs.stream_tutorial.config",
        "description": "docs.stream_tutorial.config",
        "peekOfCode": "def check_config(cls, config: \"bt.Config\"):\n    bt.axon.check_config(config)\n    bt.logging.check_config(config)\n    full_path = os.path.expanduser(\n        \"{}/{}/{}/{}\".format(\n            config.logging.logging_dir,\n            config.wallet.get(\"name\", bt.defaults.wallet.name),\n            config.wallet.get(\"hotkey\", bt.defaults.wallet.hotkey),\n            config.miner.name,\n        )",
        "detail": "docs.stream_tutorial.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "docs.stream_tutorial.config",
        "description": "docs.stream_tutorial.config",
        "peekOfCode": "def get_config() -> \"bt.Config\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--axon.port\", type=int, default=8098, help=\"Port to run the axon on.\"\n    )\n    # Subtensor network to connect to\n    parser.add_argument(\n        \"--subtensor.network\",\n        default=\"finney\",\n        help=\"Bittensor network to connect to.\",",
        "detail": "docs.stream_tutorial.config",
        "documentation": {}
    },
    {
        "label": "StreamMiner",
        "kind": 6,
        "importPath": "docs.stream_tutorial.miner",
        "description": "docs.stream_tutorial.miner",
        "peekOfCode": "class StreamMiner(ABC):\n    def __init__(self, config=None, axon=None, wallet=None, subtensor=None):\n        # Setup base config from Miner.config() and merge with subclassed config.\n        base_config = copy.deepcopy(config or get_config())\n        self.config = self.config()\n        self.config.merge(base_config)\n        check_config(StreamMiner, self.config)\n        bt.logging.info(self.config)  # TODO: duplicate print?\n        self.prompt_cache: Dict[str, Tuple[str, int]] = {}\n        # Activating Bittensor's logging with the set configurations.",
        "detail": "docs.stream_tutorial.miner",
        "documentation": {}
    },
    {
        "label": "StreamingTemplateMiner",
        "kind": 6,
        "importPath": "docs.stream_tutorial.miner",
        "description": "docs.stream_tutorial.miner",
        "peekOfCode": "class StreamingTemplateMiner(StreamMiner):\n    def config(self) -> \"bt.Config\":\n        \"\"\"\n        Returns the configuration object specific to this miner.\n        Implement and extend this method to provide custom configurations for the miner.\n        Currently, it sets up a basic configuration parser.\n        Returns:\n            bt.Config: A configuration object with the miner's operational parameters.\n        \"\"\"\n        parser = argparse.ArgumentParser(description=\"Streaming Miner Configs\")",
        "detail": "docs.stream_tutorial.miner",
        "documentation": {}
    },
    {
        "label": "StreamPrompting",
        "kind": 6,
        "importPath": "docs.stream_tutorial.protocol",
        "description": "docs.stream_tutorial.protocol",
        "peekOfCode": "class StreamPrompting(bt.StreamingSynapse):\n    \"\"\"\n    StreamPrompting is a specialized implementation of the `StreamingSynapse` tailored for prompting functionalities within\n    the Bittensor network. This class is intended to interact with a streaming response that contains a sequence of tokens,\n    which represent prompts or messages in a certain scenario.\n    As a developer, when using or extending the `StreamPrompting` class, you should be primarily focused on the structure\n    and behavior of the prompts you are working with. The class has been designed to seamlessly handle the streaming,\n    decoding, and accumulation of tokens that represent these prompts.\n    Attributes:\n    - `roles` (List[str]): A list of roles involved in the prompting scenario. This could represent different entities",
        "detail": "docs.stream_tutorial.protocol",
        "documentation": {}
    },
    {
        "label": "Miner",
        "kind": 6,
        "importPath": "neurons.miner",
        "description": "neurons.miner",
        "peekOfCode": "class Miner(BaseMinerNeuron):\n    \"\"\"The Sportstensor Miner.\"\"\"\n    def __init__(self, config=None):\n        super(Miner, self).__init__(config=config)\n        self.league_commitments = []\n        self.load_league_commitments()\n    def load_league_commitments(self):\n        load_dotenv(dotenv_path=MINER_ENV_PATH, override=True)\n        league_commitments = os.getenv(\"LEAGUE_COMMITMENTS\")\n        leagues_list = league_commitments.split(\",\")",
        "detail": "neurons.miner",
        "documentation": {}
    },
    {
        "label": "MINER_ENV_PATH",
        "kind": 5,
        "importPath": "neurons.miner",
        "description": "neurons.miner",
        "peekOfCode": "MINER_ENV_PATH = os.path.join(os.path.dirname(__file__), 'miner.env')\nclass Miner(BaseMinerNeuron):\n    \"\"\"The Sportstensor Miner.\"\"\"\n    def __init__(self, config=None):\n        super(Miner, self).__init__(config=config)\n        self.league_commitments = []\n        self.load_league_commitments()\n    def load_league_commitments(self):\n        load_dotenv(dotenv_path=MINER_ENV_PATH, override=True)\n        league_commitments = os.getenv(\"LEAGUE_COMMITMENTS\")",
        "detail": "neurons.miner",
        "documentation": {}
    },
    {
        "label": "Validator",
        "kind": 6,
        "importPath": "neurons.validator",
        "description": "neurons.validator",
        "peekOfCode": "class Validator(BaseValidatorNeuron):\n    \"\"\"\n    Your validator neuron class. You should use this class to define your validator's behavior. In particular, you should replace the forward function with your own logic.\n    This class inherits from the BaseValidatorNeuron class, which in turn inherits from BaseNeuron. The BaseNeuron class takes care of routine tasks such as setting up wallet, subtensor, metagraph, logging directory, parsing config, etc. You can override any of the methods in BaseNeuron if you need to customize the behavior.\n    This class provides reasonable default behavior for a validator such as keeping a moving average of the scores of the miners and using them to set weights at the end of each epoch. Additionally, the scores are reset for new hotkeys at the end of each epoch.\n    \"\"\"\n    def __init__(self, config=None):\n        super(Validator, self).__init__(config=config)\n        bt.logging.info(\"load_state()\")\n        self.load_state()",
        "detail": "neurons.validator",
        "documentation": {}
    },
    {
        "label": "delete_old_runs",
        "kind": 2,
        "importPath": "scripts.wandb_cleanup",
        "description": "scripts.wandb_cleanup",
        "peekOfCode": "def delete_old_runs():\n    # Get all runs in the project\n    runs = api.runs(f\"{ENTITY_NAME}/{PROJECT_NAME}\")\n    for run in runs:\n        # Convert the run's created_at timestamp to a datetime object\n        #run_created_at = datetime.strptime(run.created_at, '%Y-%m-%dT%H:%M:%S')\n        run_created_at = datetime.strptime(run.created_at, '%Y-%m-%dT%H:%M:%SZ')\n        # Check if the run is older than the cutoff date\n        if run_created_at < cutoff_date:\n            files = run.files()",
        "detail": "scripts.wandb_cleanup",
        "documentation": {}
    },
    {
        "label": "PROJECT_NAME",
        "kind": 5,
        "importPath": "scripts.wandb_cleanup",
        "description": "scripts.wandb_cleanup",
        "peekOfCode": "PROJECT_NAME = 'sportstensor-vali-logs'\nENTITY_NAME = 'sportstensor'\nDAYS_TO_KEEP = 2  # Number of days to keep logs and artifacts\n# Authenticate with wandb\nwandb.login()\n# Initialize the API\napi = wandb.Api()\n# Calculate the cutoff date\ncutoff_date = datetime.now() - timedelta(days=DAYS_TO_KEEP)\n# Function to delete old runs",
        "detail": "scripts.wandb_cleanup",
        "documentation": {}
    },
    {
        "label": "ENTITY_NAME",
        "kind": 5,
        "importPath": "scripts.wandb_cleanup",
        "description": "scripts.wandb_cleanup",
        "peekOfCode": "ENTITY_NAME = 'sportstensor'\nDAYS_TO_KEEP = 2  # Number of days to keep logs and artifacts\n# Authenticate with wandb\nwandb.login()\n# Initialize the API\napi = wandb.Api()\n# Calculate the cutoff date\ncutoff_date = datetime.now() - timedelta(days=DAYS_TO_KEEP)\n# Function to delete old runs\ndef delete_old_runs():",
        "detail": "scripts.wandb_cleanup",
        "documentation": {}
    },
    {
        "label": "DAYS_TO_KEEP",
        "kind": 5,
        "importPath": "scripts.wandb_cleanup",
        "description": "scripts.wandb_cleanup",
        "peekOfCode": "DAYS_TO_KEEP = 2  # Number of days to keep logs and artifacts\n# Authenticate with wandb\nwandb.login()\n# Initialize the API\napi = wandb.Api()\n# Calculate the cutoff date\ncutoff_date = datetime.now() - timedelta(days=DAYS_TO_KEEP)\n# Function to delete old runs\ndef delete_old_runs():\n    # Get all runs in the project",
        "detail": "scripts.wandb_cleanup",
        "documentation": {}
    },
    {
        "label": "api",
        "kind": 5,
        "importPath": "scripts.wandb_cleanup",
        "description": "scripts.wandb_cleanup",
        "peekOfCode": "api = wandb.Api()\n# Calculate the cutoff date\ncutoff_date = datetime.now() - timedelta(days=DAYS_TO_KEEP)\n# Function to delete old runs\ndef delete_old_runs():\n    # Get all runs in the project\n    runs = api.runs(f\"{ENTITY_NAME}/{PROJECT_NAME}\")\n    for run in runs:\n        # Convert the run's created_at timestamp to a datetime object\n        #run_created_at = datetime.strptime(run.created_at, '%Y-%m-%dT%H:%M:%S')",
        "detail": "scripts.wandb_cleanup",
        "documentation": {}
    },
    {
        "label": "cutoff_date",
        "kind": 5,
        "importPath": "scripts.wandb_cleanup",
        "description": "scripts.wandb_cleanup",
        "peekOfCode": "cutoff_date = datetime.now() - timedelta(days=DAYS_TO_KEEP)\n# Function to delete old runs\ndef delete_old_runs():\n    # Get all runs in the project\n    runs = api.runs(f\"{ENTITY_NAME}/{PROJECT_NAME}\")\n    for run in runs:\n        # Convert the run's created_at timestamp to a datetime object\n        #run_created_at = datetime.strptime(run.created_at, '%Y-%m-%dT%H:%M:%S')\n        run_created_at = datetime.strptime(run.created_at, '%Y-%m-%dT%H:%M:%SZ')\n        # Check if the run is older than the cutoff date",
        "detail": "scripts.wandb_cleanup",
        "documentation": {}
    },
    {
        "label": "SportstensorBaseModel",
        "kind": 6,
        "importPath": "st.models.base",
        "description": "st.models.base",
        "peekOfCode": "class SportstensorBaseModel(SportPredictionModel):\n    def __init__(self, prediction: MatchPrediction):\n        super().__init__(prediction)\n        self.boost_min_percent = 0.03\n        self.boost_max_percent = 0.10\n        self.probability_cap = 0.95\n        self.max_retries = 3\n        self.retry_delay = 0.5\n        self.timeout = 3\n    async def fetch_odds(self, sport_key: str, region: str) -> Optional[dict]:",
        "detail": "st.models.base",
        "documentation": {}
    },
    {
        "label": "MINER_ENV_PATH",
        "kind": 5,
        "importPath": "st.models.base",
        "description": "st.models.base",
        "peekOfCode": "MINER_ENV_PATH = 'neurons/miner.env'\nload_dotenv(dotenv_path=MINER_ENV_PATH)\nODDS_API_KEY = os.getenv(\"ODDS_API_KEY\")\nif not ODDS_API_KEY:\n    raise ValueError(f\"ODDS_API_KEY not found in {MINER_ENV_PATH}\")\nAPI_URL = \"https://api.the-odds-api.com/v4/sports/\"\n# Team name mappings for normalization\nmismatch_teams_mapping = {\n    \"Orlando City SC\": \"Orlando City\",\n    \"Inter Miami CF\": \"Inter Miami\",",
        "detail": "st.models.base",
        "documentation": {}
    },
    {
        "label": "ODDS_API_KEY",
        "kind": 5,
        "importPath": "st.models.base",
        "description": "st.models.base",
        "peekOfCode": "ODDS_API_KEY = os.getenv(\"ODDS_API_KEY\")\nif not ODDS_API_KEY:\n    raise ValueError(f\"ODDS_API_KEY not found in {MINER_ENV_PATH}\")\nAPI_URL = \"https://api.the-odds-api.com/v4/sports/\"\n# Team name mappings for normalization\nmismatch_teams_mapping = {\n    \"Orlando City SC\": \"Orlando City\",\n    \"Inter Miami CF\": \"Inter Miami\",\n    \"Atlanta United FC\": \"Atlanta United\",\n    \"Montreal Impact\": \"CF Montréal\",",
        "detail": "st.models.base",
        "documentation": {}
    },
    {
        "label": "API_URL",
        "kind": 5,
        "importPath": "st.models.base",
        "description": "st.models.base",
        "peekOfCode": "API_URL = \"https://api.the-odds-api.com/v4/sports/\"\n# Team name mappings for normalization\nmismatch_teams_mapping = {\n    \"Orlando City SC\": \"Orlando City\",\n    \"Inter Miami CF\": \"Inter Miami\",\n    \"Atlanta United FC\": \"Atlanta United\",\n    \"Montreal Impact\": \"CF Montréal\",\n    \"D.C. United\": \"DC United\",\n    \"Tottenham Hotspur\": \"Tottenham\",\n    \"Columbus Crew SC\": \"Columbus Crew\",",
        "detail": "st.models.base",
        "documentation": {}
    },
    {
        "label": "mismatch_teams_mapping",
        "kind": 5,
        "importPath": "st.models.base",
        "description": "st.models.base",
        "peekOfCode": "mismatch_teams_mapping = {\n    \"Orlando City SC\": \"Orlando City\",\n    \"Inter Miami CF\": \"Inter Miami\",\n    \"Atlanta United FC\": \"Atlanta United\",\n    \"Montreal Impact\": \"CF Montréal\",\n    \"D.C. United\": \"DC United\",\n    \"Tottenham Hotspur\": \"Tottenham\",\n    \"Columbus Crew SC\": \"Columbus Crew\",\n    \"Minnesota United FC\": \"Minnesota United\",\n    \"Vancouver Whitecaps FC\": \"Vancouver Whitecaps\",",
        "detail": "st.models.base",
        "documentation": {}
    },
    {
        "label": "SPORTS_TYPES",
        "kind": 5,
        "importPath": "st.models.base",
        "description": "st.models.base",
        "peekOfCode": "SPORTS_TYPES = [\n    {\n        'sport_key': 'baseball_mlb',\n        'region': 'us,eu',\n    },\n    {\n        'sport_key': 'americanfootball_nfl',\n        'region': 'us,eu'\n    },\n    {",
        "detail": "st.models.base",
        "documentation": {}
    },
    {
        "label": "league_mapping",
        "kind": 5,
        "importPath": "st.models.base",
        "description": "st.models.base",
        "peekOfCode": "league_mapping = {\n    'NBA': 'NBA',\n    'NFL': 'NFL',\n    'MLS': 'MLS',\n    'EPL': 'EPL',\n    'MLB': 'MLB',\n}\nclass SportstensorBaseModel(SportPredictionModel):\n    def __init__(self, prediction: MatchPrediction):\n        super().__init__(prediction)",
        "detail": "st.models.base",
        "documentation": {}
    },
    {
        "label": "BaseballPredictionModel",
        "kind": 6,
        "importPath": "st.models.baseball",
        "description": "st.models.baseball",
        "peekOfCode": "class BaseballPredictionModel(SportPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting baseball game...\")\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.baseball",
        "documentation": {}
    },
    {
        "label": "MLBBaseballPredictionModel",
        "kind": 6,
        "importPath": "st.models.baseball_mlb",
        "description": "st.models.baseball_mlb",
        "peekOfCode": "class MLBBaseballPredictionModel(BaseballPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting MLB baseball game...\")\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.baseball_mlb",
        "documentation": {}
    },
    {
        "label": "BasketballPredictionModel",
        "kind": 6,
        "importPath": "st.models.basketball",
        "description": "st.models.basketball",
        "peekOfCode": "class BasketballPredictionModel(SportPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting basketball game...\")\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.basketball",
        "documentation": {}
    },
    {
        "label": "NBABasketballPredictionModel",
        "kind": 6,
        "importPath": "st.models.basketball_nba",
        "description": "st.models.basketball_nba",
        "peekOfCode": "class NBABasketballPredictionModel(BasketballPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting NBA basketball game...\")\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.basketball_nba",
        "documentation": {}
    },
    {
        "label": "CricketPredictionModel",
        "kind": 6,
        "importPath": "st.models.cricket",
        "description": "st.models.cricket",
        "peekOfCode": "class CricketPredictionModel(SportPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting cricket game...\")\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.cricket",
        "documentation": {}
    },
    {
        "label": "FootballPredictionModel",
        "kind": 6,
        "importPath": "st.models.football",
        "description": "st.models.football",
        "peekOfCode": "class FootballPredictionModel(SportPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting American football game...\")\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.football",
        "documentation": {}
    },
    {
        "label": "NFLFootballPredictionModel",
        "kind": 6,
        "importPath": "st.models.football_nfl",
        "description": "st.models.football_nfl",
        "peekOfCode": "class NFLFootballPredictionModel(FootballPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting NFL football game...\")\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.football_nfl",
        "documentation": {}
    },
    {
        "label": "SoccerPredictionModel",
        "kind": 6,
        "importPath": "st.models.soccer",
        "description": "st.models.soccer",
        "peekOfCode": "class SoccerPredictionModel(SportPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting soccer match...\")\n        self.set_default_probability(canTie=True)\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.soccer",
        "documentation": {}
    },
    {
        "label": "EPLSoccerPredictionModel",
        "kind": 6,
        "importPath": "st.models.soccer_epl",
        "description": "st.models.soccer_epl",
        "peekOfCode": "class EPLSoccerPredictionModel(SoccerPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting EPL soccer match...\")\n        self.set_default_probability(canTie=True)\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.soccer_epl",
        "documentation": {}
    },
    {
        "label": "MLSSoccerPredictionModel",
        "kind": 6,
        "importPath": "st.models.soccer_mls",
        "description": "st.models.soccer_mls",
        "peekOfCode": "class MLSSoccerPredictionModel(SoccerPredictionModel):\n    async def make_prediction(self):\n        bt.logging.info(\"Predicting MLS soccer match...\")\n        self.set_default_probability(canTie=True)\n        # Set your probability predictions here\n        #self.prediction.probabilityChoice = random.choice([ProbabilityChoice.HOMETEAM, ProbabilityChoice.AWAYTEAM, ProbabilityChoice.DRAW])\n        #self.prediction.probability = 0.5",
        "detail": "st.models.soccer_mls",
        "documentation": {}
    },
    {
        "label": "SportPredictionModel",
        "kind": 6,
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "peekOfCode": "class SportPredictionModel(ABC):\n    def __init__(self, prediction):\n        self.prediction = prediction\n        self.huggingface_model = None\n    @abstractmethod\n    async def make_prediction(self):\n        pass\n    def set_default_scores(self):\n        self.prediction.homeTeamScore = 0\n        self.prediction.awayTeamScore = 0",
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "generate_random_probability_no_tie",
        "kind": 2,
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "peekOfCode": "def generate_random_probability_no_tie() -> List[float]:\n    # Generate a random probability for team A\n    prob_a = random.uniform(0.05, 0.95)\n    prob_b = 1 - prob_a\n    return [prob_a, prob_b]\ndef generate_random_probabilities_with_tie() -> List[float]:\n    # Generate random probabilities for win, lose, draw\n    total = 0\n    probs = [0, 0, 0]\n    for i in range(3):",
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "generate_random_probabilities_with_tie",
        "kind": 2,
        "importPath": "st.sport_prediction_model",
        "description": "st.sport_prediction_model",
        "peekOfCode": "def generate_random_probabilities_with_tie() -> List[float]:\n    # Generate random probabilities for win, lose, draw\n    total = 0\n    probs = [0, 0, 0]\n    for i in range(3):\n        probs[i] = random.uniform(0.1, 0.8)\n        total += probs[i]\n    # Normalize probabilities so they sum to 1\n    probs = [p / total for p in probs]\n    return probs",
        "detail": "st.sport_prediction_model",
        "documentation": {}
    },
    {
        "label": "SqliteValidatorStorage",
        "kind": 6,
        "importPath": "storage.sqlite_validator_storage",
        "description": "storage.sqlite_validator_storage",
        "peekOfCode": "class SqliteValidatorStorage(ValidatorStorage):\n    _instance: Optional['SqliteValidatorStorage'] = None\n    _lock = threading.Lock()\n    @classmethod\n    def get_instance(cls) -> 'SqliteValidatorStorage':\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = cls()\n            return cls._instance\n    \"\"\"Sqlite in-memory backed Validator Storage\"\"\"",
        "detail": "storage.sqlite_validator_storage",
        "documentation": {}
    },
    {
        "label": "tz_aware_timestamp_adapter",
        "kind": 2,
        "importPath": "storage.sqlite_validator_storage",
        "description": "storage.sqlite_validator_storage",
        "peekOfCode": "def tz_aware_timestamp_adapter(val):\n    datepart, timepart = val.split(b\" \")\n    year, month, day = map(int, datepart.split(b\"-\"))\n    if b\"+\" in timepart:\n        timepart, tz_offset = timepart.rsplit(b\"+\", 1)\n        if tz_offset == b\"00:00\":\n            tzinfo = dt.timezone.utc\n        else:\n            hours, minutes = map(int, tz_offset.split(b\":\", 1))\n            tzinfo = dt.timezone(dt.timedelta(hours=hours, minutes=minutes))",
        "detail": "storage.sqlite_validator_storage",
        "documentation": {}
    },
    {
        "label": "get_storage",
        "kind": 2,
        "importPath": "storage.sqlite_validator_storage",
        "description": "storage.sqlite_validator_storage",
        "peekOfCode": "def get_storage() -> SqliteValidatorStorage:\n    return SqliteValidatorStorage.get_instance()",
        "detail": "storage.sqlite_validator_storage",
        "documentation": {}
    },
    {
        "label": "ValidatorStorage",
        "kind": 6,
        "importPath": "storage.validator_storage",
        "description": "storage.validator_storage",
        "peekOfCode": "class ValidatorStorage(ABC):\n    \"\"\"An abstract class which defines the contract that all implementations of ValidatorStorage must fulfill.\"\"\"\n    @abstractmethod\n    def cleanup(self):\n        \"\"\"Cleans up the database.\"\"\"\n        raise NotImplemented\n    @abstractmethod\n    def insert_leagues(self, leagues: List[League]):\n        \"\"\"Stores leagues associated with sports. Indicates which leagues are active to run predictions on.\"\"\"\n        raise NotImplemented",
        "detail": "storage.validator_storage",
        "documentation": {}
    },
    {
        "label": "fetch_prediction_results",
        "kind": 2,
        "importPath": "tests.copycats",
        "description": "tests.copycats",
        "peekOfCode": "def fetch_prediction_results(\n    base_url: str,\n    miner_id: int,\n    miner_hotkey: str,\n    vali_hotkey: str,\n    force_api_fetch: bool = False\n) -> List[MatchPredictionWithMatchData]:\n    \"\"\"\n    Fetch prediction results from local cache or API and convert them to MatchPrediction objects.\n    Args:",
        "detail": "tests.copycats",
        "documentation": {}
    },
    {
        "label": "get_predictions_from_api",
        "kind": 2,
        "importPath": "tests.copycats",
        "description": "tests.copycats",
        "peekOfCode": "def get_predictions_from_api(miner_uid, miner_hotkey, league):\n    BASE_URL = \"https://api.sportstensor.com\"\n    VALI_HOTKEY = \"5GKH9FPPnWSUoeeTJp19wVtd84XqFW4pyK2ijV2GsFbhTrP1\"\n    try:\n        # Fetch all predictions\n        predictions = fetch_prediction_results(BASE_URL, miner_uid, miner_hotkey, VALI_HOTKEY)\n        #print(f\"Successfully fetched {len(predictions)} predictions for miner {miner_uid}\")\n        # Filter predictions by our start date\n        predictions = [p for p in predictions if p.prediction.predictionDate.replace(tzinfo=datetime.timezone.utc) >= COPYCAT_PUNISHMENT_START_DATE]\n        # Filter predictions by league",
        "detail": "tests.copycats",
        "documentation": {}
    },
    {
        "label": "get_matches_from_json",
        "kind": 2,
        "importPath": "tests.copycats",
        "description": "tests.copycats",
        "peekOfCode": "def get_matches_from_json():\n    matches = []\n    # Load matches from JSON file\n    with open(\".api-json/matches.json\", \"r\") as f:\n        matches_json_data = json.load(f)\n        matches_data = matches_json_data.get(\"matches\", [])\n        # Convert each match dict to Match object\n        for match_data in matches_data:\n            match = Match(\n                matchId=match_data[\"matchId\"],",
        "detail": "tests.copycats",
        "documentation": {}
    },
    {
        "label": "main_api",
        "kind": 2,
        "importPath": "tests.copycats",
        "description": "tests.copycats",
        "peekOfCode": "def main_api():\n    # Initialize our subtensor and metagraph\n    NETWORK = None # \"test\" or None\n    NETUID = 41\n    if NETWORK == \"test\":\n        NETUID = 172\n    subtensor = bittensor.subtensor(network=NETWORK)\n    metagraph: bittensor.metagraph = subtensor.metagraph(NETUID)\n    all_uids = metagraph.uids.tolist()\n    #all_uids = metagraph.uids.tolist()[:10]",
        "detail": "tests.copycats",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.copycats",
        "description": "tests.copycats",
        "peekOfCode": "def main():\n    # Initialize our subtensor and metagraph\n    NETWORK = \"test\" # \"test\" or None\n    NETUID = 41\n    if NETWORK == \"test\":\n        NETUID = 172\n    subtensor = bittensor.subtensor(network=NETWORK)\n    metagraph: bittensor.metagraph = subtensor.metagraph(NETUID)\n    all_uids = metagraph.uids.tolist()\n    #all_uids = metagraph.uids.tolist()[:10]",
        "detail": "tests.copycats",
        "documentation": {}
    },
    {
        "label": "run_filter_comparison",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def run_filter_comparison(odds_array, probabilities_array, filter_versions):\n    \"\"\"\n    Run multiple versions of gaussian filters and compare results with grouped columns\n    Parameters:\n    odds_array: array of odds values to test\n    probabilities_array: array of probability values to test\n    filter_versions: dict of filter functions to compare, e.g. {'v1': apply_gaussian_filter, 'v2': apply_gaussian_filter_v2}\n    \"\"\"\n    results = []\n    for odds in odds_array:",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "display_comparison",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def display_comparison(df, float_format=\".4f\"):\n    \"\"\"\n    Display the comparison results in a formatted table\n    \"\"\"\n    # Sort by odds and probability for better readability\n    df_sorted = df.sort_values(['odds', 'prob'])\n    # Format the table\n    table = tabulate(\n        df_sorted,\n        headers='keys',",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def main():\n    # Define filter versions to compare\n    filter_versions = {\n        'v1': apply_gaussian_filter,\n        #'v2': apply_gaussian_filter_v2,\n        #'v3': apply_gaussian_filter_v3,\n        #'v4': apply_gaussian_filter_v4\n    }\n    # Run comparison\n    results_df = run_filter_comparison(ODDS, PROBABILITIES, filter_versions)",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "main_old",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def main_old():\n    results = []\n    for odds in ODDS:\n        for prob in PROBABILITIES:\n            gfilter = apply_gaussian_filter_v2(odds, prob)\n            implied_edge = odds - 1/prob\n            final_edge = implied_edge * gfilter\n            #w = (odds - 1.0) * np.log(odds) / 2\n            results.append({\n                \"odds\": odds,",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "apply_gaussian_filter",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def apply_gaussian_filter(odds, prob):\n    sigma = np.log(1/(prob*prob))\n    w = (odds - 1.0) * np.log(odds) / 2\n    diff = abs(odds - 1/prob)\n    exp_component = 1.0 if diff <= w else np.exp(-np.power(diff, 2) / (4 * np.power(sigma, 2)))\n    return exp_component\n\"\"\"\ndef apply_gaussian_filter(odds, prob):\n    \"\"\"\n    Apply a Gaussian filter to the closing odds and prediction probability. ",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "apply_gaussian_filter",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def apply_gaussian_filter(odds, prob):\n    \"\"\"\n    Apply a Gaussian filter to the closing odds and prediction probability. \n    This filter is used to suppress the score when the prediction is far from the closing odds, simulating a more realistic prediction.\n    :param pwmd: MatchPredictionWithMatchData\n    :return: float, the calculated Gaussian filter\n    \"\"\"\n    t = 0.5 # Controls the spread/width of the Gaussian curve outside the plateau region. Larger t means slower decay in the exponential term\n    t2 = 0.05 # Controls the spread/width of the Gaussian curve inside the plateau region. t2 is used on lay predictions\n    #t2 = 0.0001 # Controls the spread/width of the Gaussian curve inside the plateau region. t2 is used on lay predictions",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "apply_gaussian_filter_v2",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def apply_gaussian_filter_v2(odds, prob):\n    ########################\n    # note that sigma^2 = odds now\n    ########################\n    t = 1.0\n    a = -2\n    b = 0.3\n    c = 3\n    w = a * np.exp(-b * (odds-1)) + c\n    diff = abs(odds - 1/prob)",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "apply_gaussian_filter_v3",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def apply_gaussian_filter_v3(odds, prob):\n    ########################\n    # note that sigma^2 = odds now\n    ########################\n    t = 0.5\n    a = -2\n    b = 0.3\n    c = 1\n    # Plateau width calculation\n    w = c - a * np.exp(-b * (odds - 1))",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "apply_gaussian_filter_v4",
        "kind": 2,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "def apply_gaussian_filter_v4(odds, prob):\n    ########################\n    # note that sigma^2 = odds now\n    ########################\n    t = 1\n    a = -2\n    b = 0.3\n    c = 2\n    w = a * np.exp(-b * (odds-1)) + c\n    diff = abs(odds - 1/prob)",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "#ODDS",
        "kind": 5,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "#ODDS = [1.65, 1.75, 1.79]\n#PROBABILITIES = [0.999, 0.99, 0.9, 0.8, 0.7, 0.671, 0.62, 0.6, 0.57, 0.5, 0.45, 0.41, 0.37, 0.35, 0.3333, 0.2857, 0.25, 0.22, 0.2, 0.1, 0.05, 0.01, 0.001, 0.0001, .00001]\nODDS = [14.84, 13.45, 10.22, 9.01, 6.03, 5.04, 4.59, 4.167, 3.89, 3.31, 3.24, 2.31, 1.75, 1.6, 1.44, 1.4, 1.25, 1.15]\nPROBABILITIES = [0.001, 0.01, 0.0467, 0.0716, 0.0844, 0.0945, 0.10, 0.111, 0.1214, 0.1343, 0.18, 0.2, 0.225, 0.267, 0.3, 0.33, 0.41, 0.465, 0.52, 0.54, 0.6145, 0.669, 0.71, 0.8, 0.88, 0.91, 0.94, 0.97, 0.99]\ndef run_filter_comparison(odds_array, probabilities_array, filter_versions):\n    \"\"\"\n    Run multiple versions of gaussian filters and compare results with grouped columns\n    Parameters:\n    odds_array: array of odds values to test\n    probabilities_array: array of probability values to test",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "#PROBABILITIES",
        "kind": 5,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "#PROBABILITIES = [0.999, 0.99, 0.9, 0.8, 0.7, 0.671, 0.62, 0.6, 0.57, 0.5, 0.45, 0.41, 0.37, 0.35, 0.3333, 0.2857, 0.25, 0.22, 0.2, 0.1, 0.05, 0.01, 0.001, 0.0001, .00001]\nODDS = [14.84, 13.45, 10.22, 9.01, 6.03, 5.04, 4.59, 4.167, 3.89, 3.31, 3.24, 2.31, 1.75, 1.6, 1.44, 1.4, 1.25, 1.15]\nPROBABILITIES = [0.001, 0.01, 0.0467, 0.0716, 0.0844, 0.0945, 0.10, 0.111, 0.1214, 0.1343, 0.18, 0.2, 0.225, 0.267, 0.3, 0.33, 0.41, 0.465, 0.52, 0.54, 0.6145, 0.669, 0.71, 0.8, 0.88, 0.91, 0.94, 0.97, 0.99]\ndef run_filter_comparison(odds_array, probabilities_array, filter_versions):\n    \"\"\"\n    Run multiple versions of gaussian filters and compare results with grouped columns\n    Parameters:\n    odds_array: array of odds values to test\n    probabilities_array: array of probability values to test\n    filter_versions: dict of filter functions to compare, e.g. {'v1': apply_gaussian_filter, 'v2': apply_gaussian_filter_v2}",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "ODDS",
        "kind": 5,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "ODDS = [14.84, 13.45, 10.22, 9.01, 6.03, 5.04, 4.59, 4.167, 3.89, 3.31, 3.24, 2.31, 1.75, 1.6, 1.44, 1.4, 1.25, 1.15]\nPROBABILITIES = [0.001, 0.01, 0.0467, 0.0716, 0.0844, 0.0945, 0.10, 0.111, 0.1214, 0.1343, 0.18, 0.2, 0.225, 0.267, 0.3, 0.33, 0.41, 0.465, 0.52, 0.54, 0.6145, 0.669, 0.71, 0.8, 0.88, 0.91, 0.94, 0.97, 0.99]\ndef run_filter_comparison(odds_array, probabilities_array, filter_versions):\n    \"\"\"\n    Run multiple versions of gaussian filters and compare results with grouped columns\n    Parameters:\n    odds_array: array of odds values to test\n    probabilities_array: array of probability values to test\n    filter_versions: dict of filter functions to compare, e.g. {'v1': apply_gaussian_filter, 'v2': apply_gaussian_filter_v2}\n    \"\"\"",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "PROBABILITIES",
        "kind": 5,
        "importPath": "tests.gaussian_filter",
        "description": "tests.gaussian_filter",
        "peekOfCode": "PROBABILITIES = [0.001, 0.01, 0.0467, 0.0716, 0.0844, 0.0945, 0.10, 0.111, 0.1214, 0.1343, 0.18, 0.2, 0.225, 0.267, 0.3, 0.33, 0.41, 0.465, 0.52, 0.54, 0.6145, 0.669, 0.71, 0.8, 0.88, 0.91, 0.94, 0.97, 0.99]\ndef run_filter_comparison(odds_array, probabilities_array, filter_versions):\n    \"\"\"\n    Run multiple versions of gaussian filters and compare results with grouped columns\n    Parameters:\n    odds_array: array of odds values to test\n    probabilities_array: array of probability values to test\n    filter_versions: dict of filter functions to compare, e.g. {'v1': apply_gaussian_filter, 'v2': apply_gaussian_filter_v2}\n    \"\"\"\n    results = []",
        "detail": "tests.gaussian_filter",
        "documentation": {}
    },
    {
        "label": "CLOSE_IN_VALUE",
        "kind": 6,
        "importPath": "tests.helpers",
        "description": "tests.helpers",
        "peekOfCode": "class CLOSE_IN_VALUE:\n    value: Union[float, int, Balance]\n    tolerance: Union[float, int, Balance]\n    def __init__(\n        self,\n        value: Union[float, int, Balance],\n        tolerance: Union[float, int, Balance] = 0.0,\n    ) -> None:\n        self.value = value\n        self.tolerance = tolerance",
        "detail": "tests.helpers",
        "documentation": {}
    },
    {
        "label": "MockStatus",
        "kind": 6,
        "importPath": "tests.helpers",
        "description": "tests.helpers",
        "peekOfCode": "class MockStatus:\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_value, traceback):\n        pass\n    def start(self):\n        pass\n    def stop(self):\n        pass\n    def update(self, *args, **kwargs):",
        "detail": "tests.helpers",
        "documentation": {}
    },
    {
        "label": "MockConsole",
        "kind": 6,
        "importPath": "tests.helpers",
        "description": "tests.helpers",
        "peekOfCode": "class MockConsole:\n    \"\"\"\n    Mocks the console object for status and print.\n    Captures the last print output as a string.\n    \"\"\"\n    captured_print = None\n    def status(self, *args, **kwargs):\n        return MockStatus()\n    def print(self, *args, **kwargs):\n        console = Console(",
        "detail": "tests.helpers",
        "documentation": {}
    },
    {
        "label": "get_mock_neuron",
        "kind": 2,
        "importPath": "tests.helpers",
        "description": "tests.helpers",
        "peekOfCode": "def get_mock_neuron(**kwargs) -> NeuronInfo:\n    \"\"\"\n    Returns a mock neuron with the given kwargs overriding the default values.\n    \"\"\"\n    mock_neuron_d = dict(\n        {\n            \"netuid\": -1,  # mock netuid\n            \"axon_info\": AxonInfo(\n                block=0,\n                version=1,",
        "detail": "tests.helpers",
        "documentation": {}
    },
    {
        "label": "get_mock_neuron_by_uid",
        "kind": 2,
        "importPath": "tests.helpers",
        "description": "tests.helpers",
        "peekOfCode": "def get_mock_neuron_by_uid(uid: int, **kwargs) -> NeuronInfo:\n    return get_mock_neuron(\n        uid=uid,\n        hotkey=_get_mock_hotkey(uid),\n        coldkey=_get_mock_coldkey(uid),\n        **kwargs\n    )\nclass MockStatus:\n    def __enter__(self):\n        return self",
        "detail": "tests.helpers",
        "documentation": {}
    },
    {
        "label": "connect_to_db",
        "kind": 2,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "def connect_to_db(db_name='SportsTensorEdge.db'):\n    conn = sqlite3.connect(db_name)\n    return conn, conn.cursor()\ndef close_db(conn):\n    conn.commit()\n    conn.close()\ndef get_recently_completed_matches(cursor, days_ago=5, limit=30):\n    query = \"\"\"\n    SELECT m.matchId, m.matchDate, m.sport, m.league, m.homeTeamName, m.awayTeamName, \n           m.homeTeamScore, m.awayTeamScore, m.homeTeamOdds, m.awayTeamOdds, m.drawOdds",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "close_db",
        "kind": 2,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "def close_db(conn):\n    conn.commit()\n    conn.close()\ndef get_recently_completed_matches(cursor, days_ago=5, limit=30):\n    query = \"\"\"\n    SELECT m.matchId, m.matchDate, m.sport, m.league, m.homeTeamName, m.awayTeamName, \n           m.homeTeamScore, m.awayTeamScore, m.homeTeamOdds, m.awayTeamOdds, m.drawOdds\n    FROM Matches m\n    WHERE m.matchDate >= datetime('now', ?)\n    AND m.isComplete = 1",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "get_recently_completed_matches",
        "kind": 2,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "def get_recently_completed_matches(cursor, days_ago=5, limit=30):\n    query = \"\"\"\n    SELECT m.matchId, m.matchDate, m.sport, m.league, m.homeTeamName, m.awayTeamName, \n           m.homeTeamScore, m.awayTeamScore, m.homeTeamOdds, m.awayTeamOdds, m.drawOdds\n    FROM Matches m\n    WHERE m.matchDate >= datetime('now', ?)\n    AND m.isComplete = 1\n    AND m.homeTeamOdds IS NOT NULL\n    AND m.awayTeamOdds IS NOT NULL\n    ORDER BY m.matchDate DESC",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "odds_to_probability",
        "kind": 2,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "def odds_to_probability(odds):\n    return 1 / odds if odds else 0\ndef generate_prediction(match, time_to_match, miner_info=None):\n    match_id, match_date, sport, league, home_team, away_team, home_score, away_score, home_odds, away_odds, draw_odds = match\n    # Determine the actual outcome\n    if home_score > away_score:\n        actual_outcome = ProbabilityChoice.HOMETEAM\n        actual_odds = home_odds\n    elif away_score > home_score:\n        actual_outcome = ProbabilityChoice.AWAYTEAM",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "generate_prediction",
        "kind": 2,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "def generate_prediction(match, time_to_match, miner_info=None):\n    match_id, match_date, sport, league, home_team, away_team, home_score, away_score, home_odds, away_odds, draw_odds = match\n    # Determine the actual outcome\n    if home_score > away_score:\n        actual_outcome = ProbabilityChoice.HOMETEAM\n        actual_odds = home_odds\n    elif away_score > home_score:\n        actual_outcome = ProbabilityChoice.AWAYTEAM\n        actual_odds = away_odds\n    else:",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "generate_duplicate_predictions",
        "kind": 2,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "def generate_duplicate_predictions(match, time_to_match, duplicate_group):\n    \"\"\"Generate identical predictions for a group of miners with small timing variations.\"\"\"\n    base_prediction = generate_prediction(match, time_to_match, duplicate_group[0])\n    predictions = []\n    for miner_info in duplicate_group:\n        dup_prediction = base_prediction.copy()\n        dup_prediction['minerId'] = miner_info[0]\n        dup_prediction['hotkey'] = miner_info[1]\n        # Add small random variations to timestamps (within 2 seconds)\n        pred_date = datetime.strptime(dup_prediction['predictionDate'], '%Y-%m-%d %H:%M:%S')",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "insert_predictions",
        "kind": 2,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "def insert_predictions(cursor, predictions):\n    insert_query = \"\"\"\n    INSERT OR IGNORE INTO MatchPredictions (minerId, hotkey, matchId, matchDate, sport, league, homeTeamName, awayTeamName, homeTeamScore, awayTeamScore, probabilityChoice, probability, predictionDate, lastUpdated)\n    VALUES (:minerId, :hotkey, :matchId, :matchDate, :sport, :league, :homeTeamName, :awayTeamName, :homeTeamScore, :awayTeamScore, :probabilityChoice, :probability, :predictionDate, :lastUpdated)\n    \"\"\"\n    cursor.executemany(insert_query, predictions)\ndef main():\n    conn, cursor = connect_to_db()\n    matches = get_recently_completed_matches(cursor, limit=10)\n    all_predictions = []",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "def main():\n    conn, cursor = connect_to_db()\n    matches = get_recently_completed_matches(cursor, limit=10)\n    all_predictions = []\n    time_intervals = [\n        timedelta(hours=24),\n        timedelta(hours=12),\n        timedelta(hours=4),\n        timedelta(minutes=10)\n    ]",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "MINERS",
        "kind": 5,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "MINERS = [\n    (1, \"5EqZoEKc6c8TaG4xRRHTT1uZiQF5jkjQCeUV5t77L6YbeaJ8\"),\n    (54, \"5EkPSGp7Yt63j1WdFvKduvv2fuXaJKhPyN8cm7jQ5cp1hvBC\"),\n    (57, \"5HDkQ6hUR31yXBvuwXXQzrB14xseuUmgPBbm1ApR1tN3uw7q\"),\n    (65, \"5DPdXPrYCTnsUDh2nYZMCAUb3d6h8eouDCF3zhdw8ru3czSm\"),\n    (69, \"5HNAS5jXy3xX4kUKH4qSoncTTGpwJKNCNNE3CxK8GRtCU5XU\"),\n    (68, \"5Cg6KJrRV1ceYK8uWFPSY2T1DeJ3guivS8VAfgQqkrKFBSEz\"),\n    (70, \"5DPvseipTrLhBikPsH6WNCVnYSVtJt9Sf9h39UWNpSipymGj\"),\n    (51, \"5Gjbs1prGBoXyK1uRmdnsvBkumrRb65n6ufb41D9x2RZgCpR\"),\n    (13, \"5H1GFPwHKdBeE9GacGuxUcJt8vT8Qri4LU5MGQj98AmjRqR3\")",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "DUPLICATE_GROUPS",
        "kind": 5,
        "importPath": "tests.insert_predictions",
        "description": "tests.insert_predictions",
        "peekOfCode": "DUPLICATE_GROUPS = [\n    [(1, \"5EqZoEKc6c8TaG4xRRHTT1uZiQF5jkjQCeUV5t77L6YbeaJ8\"), \n     (54, \"5EkPSGp7Yt63j1WdFvKduvv2fuXaJKhPyN8cm7jQ5cp1hvBC\")],\n    [(57, \"5HDkQ6hUR31yXBvuwXXQzrB14xseuUmgPBbm1ApR1tN3uw7q\"),\n     (65, \"5DPdXPrYCTnsUDh2nYZMCAUb3d6h8eouDCF3zhdw8ru3czSm\"),\n     (69, \"5HNAS5jXy3xX4kUKH4qSoncTTGpwJKNCNNE3CxK8GRtCU5XU\")]\n]\ndef connect_to_db(db_name='SportsTensorEdge.db'):\n    conn = sqlite3.connect(db_name)\n    return conn, conn.cursor()",
        "detail": "tests.insert_predictions",
        "documentation": {}
    },
    {
        "label": "apply_pareto",
        "kind": 2,
        "importPath": "tests.pareto",
        "description": "tests.pareto",
        "peekOfCode": "def apply_pareto(all_scores, all_uids, mu, alpha):\n    scores_array = np.array(all_scores)\n    # Treat all non-positive scores less than 1 as zero\n    positive_mask = scores_array > 0\n    positive_scores = scores_array[positive_mask]\n    transformed_scores = np.zeros_like(scores_array, dtype=float)\n    print(f\"Positive scores: {positive_scores}\")\n    print(f\"Min: {min(positive_scores)}\")\n    range_transformed = (positive_scores - np.min(positive_scores)) + 1\n    print(f\"Range transformed: {range_transformed}\")",
        "detail": "tests.pareto",
        "documentation": {}
    },
    {
        "label": "#all_uids",
        "kind": 5,
        "importPath": "tests.pareto",
        "description": "tests.pareto",
        "peekOfCode": "#all_uids = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n#all_scores = [17, 12, -1, 38, 0, 0.000001, 0.04, 1, 1.2, 0.007]\nall_uids = list(range(73))  # 0 to 72, matching the UIDs in the log\nall_scores = [\n    -3, -2.5231, -2.91235, -2.99362, -3, 0.24, -3, -3, -3, -3,\n    -3, -3, -3, -2.0793, -3, -3, -3, -3, -3, -3,\n    -3, 0.0296598, -3, -3, -3, -3, -3, -3, -3, -3,\n    -3, -3, -3, -3, -3, -3, -3, 0, -3, -3,\n    -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,\n    -3, -2.52537, -3, -3, -2.32464, -3, -3, 2.13207, -3, -3,",
        "detail": "tests.pareto",
        "documentation": {}
    },
    {
        "label": "#all_scores",
        "kind": 5,
        "importPath": "tests.pareto",
        "description": "tests.pareto",
        "peekOfCode": "#all_scores = [17, 12, -1, 38, 0, 0.000001, 0.04, 1, 1.2, 0.007]\nall_uids = list(range(73))  # 0 to 72, matching the UIDs in the log\nall_scores = [\n    -3, -2.5231, -2.91235, -2.99362, -3, 0.24, -3, -3, -3, -3,\n    -3, -3, -3, -2.0793, -3, -3, -3, -3, -3, -3,\n    -3, 0.0296598, -3, -3, -3, -3, -3, -3, -3, -3,\n    -3, -3, -3, -3, -3, -3, -3, 0, -3, -3,\n    -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,\n    -3, -2.52537, -3, -3, -2.32464, -3, -3, 2.13207, -3, -3,\n    -3, -3, -3, -3, -3, 1.38769, -3, -3, -1.93823, -1.63695,",
        "detail": "tests.pareto",
        "documentation": {}
    },
    {
        "label": "all_uids",
        "kind": 5,
        "importPath": "tests.pareto",
        "description": "tests.pareto",
        "peekOfCode": "all_uids = list(range(73))  # 0 to 72, matching the UIDs in the log\nall_scores = [\n    -3, -2.5231, -2.91235, -2.99362, -3, 0.24, -3, -3, -3, -3,\n    -3, -3, -3, -2.0793, -3, -3, -3, -3, -3, -3,\n    -3, 0.0296598, -3, -3, -3, -3, -3, -3, -3, -3,\n    -3, -3, -3, -3, -3, -3, -3, 0, -3, -3,\n    -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,\n    -3, -2.52537, -3, -3, -2.32464, -3, -3, 2.13207, -3, -3,\n    -3, -3, -3, -3, -3, 1.38769, -3, -3, -1.93823, -1.63695,\n    1.12741, -3, -3, -3, -3",
        "detail": "tests.pareto",
        "documentation": {}
    },
    {
        "label": "all_scores",
        "kind": 5,
        "importPath": "tests.pareto",
        "description": "tests.pareto",
        "peekOfCode": "all_scores = [\n    -3, -2.5231, -2.91235, -2.99362, -3, 0.24, -3, -3, -3, -3,\n    -3, -3, -3, -2.0793, -3, -3, -3, -3, -3, -3,\n    -3, 0.0296598, -3, -3, -3, -3, -3, -3, -3, -3,\n    -3, -3, -3, -3, -3, -3, -3, 0, -3, -3,\n    -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,\n    -3, -2.52537, -3, -3, -2.32464, -3, -3, 2.13207, -3, -3,\n    -3, -3, -3, -3, -3, 1.38769, -3, -3, -1.93823, -1.63695,\n    1.12741, -3, -3, -3, -3\n]",
        "detail": "tests.pareto",
        "documentation": {}
    },
    {
        "label": "mu",
        "kind": 5,
        "importPath": "tests.pareto",
        "description": "tests.pareto",
        "peekOfCode": "mu = 1\nalpha = 1.0\ntransformed_scores, uids = apply_pareto(all_scores, all_uids, mu, alpha)\nprint(\"Original scores:\", all_scores)\nprint(\"Transformed scores:\", transformed_scores)\nprint(\"UIDs:\", uids)\n# Additional information\nfor uid, original, transformed in zip(uids, all_scores, transformed_scores):\n    print(f\"UID: {uid}, Original: {original}, Transformed: {transformed:.2f}\")",
        "detail": "tests.pareto",
        "documentation": {}
    },
    {
        "label": "alpha",
        "kind": 5,
        "importPath": "tests.pareto",
        "description": "tests.pareto",
        "peekOfCode": "alpha = 1.0\ntransformed_scores, uids = apply_pareto(all_scores, all_uids, mu, alpha)\nprint(\"Original scores:\", all_scores)\nprint(\"Transformed scores:\", transformed_scores)\nprint(\"UIDs:\", uids)\n# Additional information\nfor uid, original, transformed in zip(uids, all_scores, transformed_scores):\n    print(f\"UID: {uid}, Original: {original}, Transformed: {transformed:.2f}\")",
        "detail": "tests.pareto",
        "documentation": {}
    },
    {
        "label": "calculate_incentives_and_update_scores",
        "kind": 2,
        "importPath": "tests.sim_scoring_utils",
        "description": "tests.sim_scoring_utils",
        "peekOfCode": "def calculate_incentives_and_update_scores():\n    \"\"\"\n    Calculate the incentives and update the scores for all miners with predictions.\n    This function:\n    1. Loops through every league\n    2. For each league, loops through every miner\n    4. Calculates incentives for miners committed to the league\n    5. Updates scores for each miner for each league\n    6. Updates the validator scores for each miner to set their weights\n    7. Logs detailed results for each league and final scores",
        "detail": "tests.sim_scoring_utils",
        "documentation": {}
    },
    {
        "label": "graph_results",
        "kind": 2,
        "importPath": "tests.sim_scoring_utils",
        "description": "tests.sim_scoring_utils",
        "peekOfCode": "def graph_results(all_uids, all_scores, final_scores, uids_to_league):\n    \"\"\"\n    Graphs the Pre-Pareto and Final Pareto scores with league-based color coding.\n    :param all_uids: List of unique identifiers for the miners\n    :param all_scores: List of Pre-Pareto scores\n    :param final_scores: List of Final Pareto scores\n    :param uids_to_league: Dictionary mapping miner UID to league\n    \"\"\"\n    # Sort the miners based on Final Pareto Scores\n    sorted_indices = np.argsort(final_scores)",
        "detail": "tests.sim_scoring_utils",
        "documentation": {}
    },
    {
        "label": "test_mock_subtensor",
        "kind": 2,
        "importPath": "tests.test_mock",
        "description": "tests.test_mock",
        "peekOfCode": "def test_mock_subtensor(netuid, n, wallet):\n    subtensor = MockSubtensor(netuid=netuid, n=n, wallet=wallet)\n    neurons = subtensor.neurons(netuid=netuid)\n    # Check netuid\n    assert subtensor.subnet_exists(netuid)\n    # Check network\n    assert subtensor.network == \"mock\"\n    assert subtensor.chain_endpoint == \"mock_endpoint\"\n    # Check number of neurons\n    assert len(neurons) == (n + 1 if wallet is not None else n)",
        "detail": "tests.test_mock",
        "documentation": {}
    },
    {
        "label": "test_mock_metagraph",
        "kind": 2,
        "importPath": "tests.test_mock",
        "description": "tests.test_mock",
        "peekOfCode": "def test_mock_metagraph(n):\n    mock_subtensor = MockSubtensor(netuid=1, n=n)\n    mock_metagraph = MockMetagraph(subtensor=mock_subtensor)\n    # Check axons\n    axons = mock_metagraph.axons\n    assert len(axons) == n\n    # Check ip and port\n    for axon in axons:\n        assert type(axon) == bt.AxonInfo\n        assert axon.ip == mock_metagraph.default_ip",
        "detail": "tests.test_mock",
        "documentation": {}
    },
    {
        "label": "test_mock_reward_pipeline",
        "kind": 2,
        "importPath": "tests.test_mock",
        "description": "tests.test_mock",
        "peekOfCode": "def test_mock_reward_pipeline():\n    pass\ndef test_mock_neuron():\n    pass\n@pytest.mark.parametrize(\"timeout\", [0.1, 0.2])\n@pytest.mark.parametrize(\"min_time\", [0, 0.05, 0.1])\n@pytest.mark.parametrize(\"max_time\", [0.1, 0.15, 0.2])\n@pytest.mark.parametrize(\"n\", [4, 16, 64])\ndef test_mock_dendrite_timings(timeout, min_time, max_time, n):\n    mock_wallet = None",
        "detail": "tests.test_mock",
        "documentation": {}
    },
    {
        "label": "test_mock_neuron",
        "kind": 2,
        "importPath": "tests.test_mock",
        "description": "tests.test_mock",
        "peekOfCode": "def test_mock_neuron():\n    pass\n@pytest.mark.parametrize(\"timeout\", [0.1, 0.2])\n@pytest.mark.parametrize(\"min_time\", [0, 0.05, 0.1])\n@pytest.mark.parametrize(\"max_time\", [0.1, 0.15, 0.2])\n@pytest.mark.parametrize(\"n\", [4, 16, 64])\ndef test_mock_dendrite_timings(timeout, min_time, max_time, n):\n    mock_wallet = None\n    mock_dendrite = MockDendrite(mock_wallet)\n    mock_dendrite.min_time = min_time",
        "detail": "tests.test_mock",
        "documentation": {}
    },
    {
        "label": "test_mock_dendrite_timings",
        "kind": 2,
        "importPath": "tests.test_mock",
        "description": "tests.test_mock",
        "peekOfCode": "def test_mock_dendrite_timings(timeout, min_time, max_time, n):\n    mock_wallet = None\n    mock_dendrite = MockDendrite(mock_wallet)\n    mock_dendrite.min_time = min_time\n    mock_dendrite.max_time = max_time\n    mock_subtensor = MockSubtensor(netuid=1, n=n)\n    mock_metagraph = MockMetagraph(subtensor=mock_subtensor)\n    axons = mock_metagraph.axons\n    async def run():\n        return await mock_dendrite(",
        "detail": "tests.test_mock",
        "documentation": {}
    },
    {
        "label": "API_ENDPOINT",
        "kind": 5,
        "importPath": "tests.test_sync_match_data",
        "description": "tests.test_sync_match_data",
        "peekOfCode": "API_ENDPOINT = \"http://95.179.153.99:8000/matches\"  # Use a test endpoint if necessary\nasync def sync_match_data(match_data_endpoint) -> bool:\n    storage = SqliteValidatorStorage()  \n    try:\n        async with ClientSession() as session:\n            async with session.get(match_data_endpoint) as response:\n                response.raise_for_status()\n                match_data = await response.json()\n        if not match_data:\n            logging.info(\"No match data returned from API\")",
        "detail": "tests.test_sync_match_data",
        "documentation": {}
    },
    {
        "label": "TemplateValidatorNeuronTestCase",
        "kind": 6,
        "importPath": "tests.test_template_validator",
        "description": "tests.test_template_validator",
        "peekOfCode": "class TemplateValidatorNeuronTestCase(unittest.TestCase):\n    \"\"\"\n    This class contains unit tests for the RewardEvent classes.\n    The tests cover different scenarios where completions may or may not be successful and the reward events are checked that they don't contain missing values.\n    The `reward` attribute of all RewardEvents is expected to be a float, and the `is_filter_model` attribute is expected to be a boolean.\n    \"\"\"\n    def setUp(self):\n        sys.argv = sys.argv[0] + [\"--config\", \"tests/configs/validator.json\"]\n        config = BaseValidatorNeuron.config()\n        config.wallet._mock = True",
        "detail": "tests.test_template_validator",
        "documentation": {}
    },
    {
        "label": "StatisticalAnalyzer",
        "kind": 6,
        "importPath": "vali_utils.analysis_utils",
        "description": "vali_utils.analysis_utils",
        "peekOfCode": "class StatisticalAnalyzer:\n    def __init__(self, variance_threshold: float = COPYCAT_VARIANCE_THRESHOLD, min_suspicious_matches: int = EXACT_MATCH_PREDICTIONS_THRESHOLD):\n        self.variance_threshold = variance_threshold\n        self.min_suspicious_matches = min_suspicious_matches\n    def analyze_prediction_clusters(\n        self,\n        predictions: list[MatchPredictionWithMatchData],\n        ordered_matches: List[tuple[str, datetime]],\n        excluded_miners: set[int] = None\n    ) -> dict[str, list[tuple]]:",
        "detail": "vali_utils.analysis_utils",
        "documentation": {}
    },
    {
        "label": "CopycatDetectionController",
        "kind": 6,
        "importPath": "vali_utils.copycat_controller",
        "description": "vali_utils.copycat_controller",
        "peekOfCode": "class CopycatDetectionController:\n    def __init__(\n        self,\n    ):  \n        # Initialize analyzers\n        self.statistical_analyzer = StatisticalAnalyzer()\n    def analyze_league(\n        self,\n        league: League,\n        league_predictions: List[MatchPredictionWithMatchData] = None,",
        "detail": "vali_utils.copycat_controller",
        "documentation": {}
    },
    {
        "label": "PredictionIntegrityController",
        "kind": 6,
        "importPath": "vali_utils.prediction_integrity_controller",
        "description": "vali_utils.prediction_integrity_controller",
        "peekOfCode": "class PredictionIntegrityController:\n    def __init__(\n        self,\n        prob_correlation_weight: float = 0.4,\n        choice_agreement_weight: float = 0.6,\n    ):\n        \"\"\"\n        Initialize the Prediction Integrity controller.\n        Args:\n            prob_correlation_weight: Weight for probability correlation in similarity score",
        "detail": "vali_utils.prediction_integrity_controller",
        "documentation": {}
    },
    {
        "label": "calculate_edge",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def calculate_edge(prediction_team: str, prediction_prob: float, actual_team: str, closing_odds: float | None) -> Tuple[float, int]:\n    \"\"\"\n    Calculate the edge for a prediction on a three-sided market.\n    :param prediction_team: str, either 'A' or 'B' or 'Draw' representing the team chosen\n    :param prediction_prob: float, weak learner's probability of winning for the chosen team at prediction time\n    :param actual_team: str, either 'A' or 'B', representing the team that actually won\n    :param closing_odds: float, consensus probability of outcome at match start time\n    :return: Tuple[float, int], the calculated edge and a correctness indicator (1 if correct, 0 otherwise)\n    \"\"\"\n    model_prediction_correct = (prediction_team == actual_team)",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "compute_significance_score",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def compute_significance_score(num_miner_predictions: int, num_threshold_predictions: int, alpha: float) -> float:\n    \"\"\"\n    Based on the number of predictions, calculate the statistical signifigance score.\n    :param num_miner_predictions: int, the number of predictions made by the miner\n    :param num_threshold_predictions: int, the number of predictions made by the threshold\n    :param alpha: float, the sensitivity alpha\n    :return: float, the calculated significance score\n    \"\"\"\n    exponent = -alpha * (num_miner_predictions - num_threshold_predictions)\n    denominator = 1 + math.exp(exponent)",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "apply_gaussian_filter",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def apply_gaussian_filter(pwmd: MatchPredictionWithMatchData) -> float:\n    \"\"\"\n    Apply a Gaussian filter to the closing odds and prediction probability. \n    This filter is used to suppress the score when the prediction is far from the closing odds, simulating a more realistic prediction.\n    :param pwmd: MatchPredictionWithMatchData\n    :return: float, the calculated Gaussian filter\n    \"\"\"\n    closing_odds = pwmd.get_closing_odds_for_predicted_outcome()\n    t = 0.5 # Controls the spread/width of the Gaussian curve outside the plateau region. Larger t means slower decay in the exponential term\n    t2 = 0.10 # Controls the spread/width of the Gaussian curve inside the plateau region. t2 is used on lay predictions",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "calculate_incentive_score",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def calculate_incentive_score(delta_t: int, clv: float, gamma: float, kappa: float, beta: float) -> float:\n    \"\"\"\n    Calculate the incentive score considering time differential and closing line value.\n    :param delta_t: int, the time differential in minutes\n    :param clv: float, the miner's closing line value\n    :param gamma: float, the time decay gamma\n    :param kappa: float, the transition kappa\n    :param beta: float, the extremis beta\n    :return: float, the calculated incentive score\n    \"\"\"",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "calculate_clv",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def calculate_clv(match_odds: List[Tuple[str, float, float, float, datetime]], pwmd: MatchPredictionWithMatchData, log_prediction: bool = False) -> Optional[float]:\n    \"\"\"\n    Calculate the closing line value for this prediction.\n    :param match_odds: List of tuples (matchId, homeTeamOdds, awayTeamOdds, drawOdds, lastUpdated)\n    :param pwmd: MatchPredictionWithMatchData\n    :return: float, closing line value, or None if unable to calculate\n    \"\"\"\n    # Find the odds for the match at the time of the prediction\n    prediction_odds = find_closest_odds(match_odds, pwmd.prediction.predictionDate, pwmd.prediction.probabilityChoice, log_prediction)\n    if prediction_odds is None:",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "find_closest_odds",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def find_closest_odds(match_odds: List[Tuple[str, float, float, float, datetime]], prediction_time: datetime, probability_choice: str, log_prediction: bool) -> Optional[float]:\n    \"\"\"\n    Find the closest odds to the prediction time, ensuring the odds are before or at the prediction time.\n    :param match_odds: List of tuples (matchId, homeTeamOdds, awayTeamOdds, drawOdds, lastUpdated)\n    :param prediction_time: DateTime of the prediction\n    :param probability_choice: ProbabilityChoice selection of the prediction\n    :return: The closest odds value before or at the prediction time, or None if no suitable odds are found\n    \"\"\"\n    closest_odds = None\n    closest_odds_time = None",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "apply_pareto",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def apply_pareto(all_scores: List[float], all_uids: List[int], mu: float, alpha: int) -> List[float]:\n    \"\"\"\n    Apply a Pareto distribution to the scores.\n    :param all_scores: List of scores to apply the Pareto distribution to\n    :param all_uids: List of UIDs corresponding to the scores\n    :param mu: Minimum value for the Pareto distribution\n    :param alpha: Shape parameter for the Pareto distribution\n    :return: List of scores after applying the Pareto distribution\n    \"\"\"\n    scores_array = np.array(all_scores)",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "check_and_apply_league_commitment_penalties",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def check_and_apply_league_commitment_penalties(vali, all_scores: List[float], all_uids: List[int]) -> List[float]:\n    \"\"\"\n    Check if all miners have at least one league commitment. If not, penalize to ensure that miners are committed to at least one league.\n    :param vali: Validator, the validator object\n    :param all_scores: List of scores to check and penalize\n    :param all_uids: List of UIDs corresponding to the scores\n    :return: List of scores after penalizing miners not committed to any active leagues\n    \"\"\"\n    no_commitment_miner_uids = []\n    for i, uid in enumerate(all_uids):",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "apply_no_prediction_response_penalties",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def apply_no_prediction_response_penalties(\n        metagraph: bt.metagraph, \n        league: League, \n        uids_to_last_leagues: Dict[int, List[League]], \n        uids_to_leagues_last_updated: Dict[int, dt.datetime],\n        league_rhos: Dict[League, List[float]],\n        league_scores: List[float], \n        all_uids: List[int]\n    ) -> List[float]:\n    \"\"\"",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "calculate_incentives_and_update_scores",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def calculate_incentives_and_update_scores(vali):\n    \"\"\"\n    Calculate the incentives and update the scores for all miners with predictions.\n    This function:\n    1. Loops through every league\n    2. For each league, loops through every miner\n    4. Calculates incentives for miners committed to the league\n    5. Updates scores for each miner for each league\n    6. Updates the validator scores for each miner to set their weights\n    7. Logs detailed results for each league and final scores",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "update_miner_scores",
        "kind": 2,
        "importPath": "vali_utils.scoring_utils",
        "description": "vali_utils.scoring_utils",
        "peekOfCode": "def update_miner_scores(vali, rewards: np.ndarray, uids: List[int]):\n    \"\"\"Performs exponential moving average on the scores based on the rewards received from the miners.\"\"\"\n    # Check if rewards contains NaN values.\n    if np.isnan(rewards).any():\n        bt.logging.warning(f\"NaN values detected in rewards: {rewards}\")\n        # Replace any NaN values in rewards with 0.\n        rewards = np.nan_to_num(rewards, nan=0)\n    # Ensure rewards is a numpy array.\n    rewards = np.asarray(rewards)\n    # Check if `uids` is already a numpy array and copy it to avoid the warning.",
        "detail": "vali_utils.scoring_utils",
        "documentation": {}
    },
    {
        "label": "fetch_match_odds",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def fetch_match_odds(vali, match_odds_data_endpoint: str, match_id: str) -> Dict:\n    url = f\"{match_odds_data_endpoint}?matchId={match_id}\"\n    keypair = vali.dendrite.keypair\n    hotkey = keypair.ss58_address\n    signature = f\"0x{keypair.sign(hotkey).hex()}\"\n    response = requests.get(\n        url, \n        auth=HTTPBasicAuth(hotkey, signature),\n        timeout=10\n    )",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "sync_match_odds_data",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def sync_match_odds_data(vali, match_odds_data_endpoint: str) -> bool:\n    try:\n        # Get matches from the last MATCH_ODDS_CUTOFF_IN_DAYS days\n        x_days_ago = dt.datetime.now(dt.timezone.utc) - dt.timedelta(days=MATCH_ODDS_CUTOFF_IN_DAYS)\n        recent_matches = storage.get_recently_completed_matches(x_days_ago)\n        if not recent_matches:\n            bt.logging.debug(\"No recent matches found in the database\")\n            return False\n        odds_to_insert = []\n        for match in recent_matches:",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "clean_up_unscored_deregistered_match_predictions",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def clean_up_unscored_deregistered_match_predictions(active_miner_hotkeys: List[str]):\n    \"\"\"Deletes unscored predictions returned from miners that are no longer registered.\"\"\"\n    try:\n        storage.delete_unscored_deregistered_match_predictions(active_miner_hotkeys)\n    except Exception as e:\n        bt.logging.error(f\"Error cleaning up unscored deregistered predictions: {e}\")\ndef get_match_prediction_requests(vali: Validator) -> Tuple[List[MatchPrediction], str]:\n    matches = storage.get_matches_to_predict()\n    if not matches:\n        return [], \"No upcoming matches scheduled.\"",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "get_match_prediction_requests",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def get_match_prediction_requests(vali: Validator) -> Tuple[List[MatchPrediction], str]:\n    matches = storage.get_matches_to_predict()\n    if not matches:\n        return [], \"No upcoming matches scheduled.\"\n    for match in matches:\n        # Check if the matchId is in the database already and fix if needed\n        storage.check_and_fix_match_prediction_requests(match.matchId)\n    current_time = dt.datetime.now(dt.timezone.utc)\n    match_prediction_requests = storage.get_match_prediction_requests()\n    match_predictions = []",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "clean_up_unscored_deregistered_match_predictions",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def clean_up_unscored_deregistered_match_predictions(active_miner_hotkeys: List[str], active_miner_uids: List[int]):\n    \"\"\"Deletes unscored predictions returned from miners that are no longer registered.\"\"\"\n    try:\n        storage.delete_unscored_deregistered_match_predictions(active_miner_hotkeys, active_miner_uids)\n    except Exception as e:\n        bt.logging.error(f\"Error cleaning up unscored deregistered predictions: {e}\")\ndef archive_deregistered_match_predictions(active_miner_hotkeys: List[str], active_miner_uids: List[int]):\n    \"\"\"Archives predictions from miners that are no longer registered.\"\"\"\n    try:\n        storage.archive_match_predictions(active_miner_hotkeys, active_miner_uids)",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "archive_deregistered_match_predictions",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def archive_deregistered_match_predictions(active_miner_hotkeys: List[str], active_miner_uids: List[int]):\n    \"\"\"Archives predictions from miners that are no longer registered.\"\"\"\n    try:\n        storage.archive_match_predictions(active_miner_hotkeys, active_miner_uids)\n    except Exception as e:\n        bt.logging.error(f\"Error archiving unscored deregistered predictions: {e}\")\ndef find_and_score_edge_match_predictions(batchsize: int) -> Tuple[List[float], List[int], List[int], List[str], List[str]]:\n    \"\"\"Query the validator's local storage for a list of qualifying MatchPredictions that can be scored.\n    Then run Closing Edge calculations and return results\n    \"\"\"",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "find_and_score_edge_match_predictions",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def find_and_score_edge_match_predictions(batchsize: int) -> Tuple[List[float], List[int], List[int], List[str], List[str]]:\n    \"\"\"Query the validator's local storage for a list of qualifying MatchPredictions that can be scored.\n    Then run Closing Edge calculations and return results\n    \"\"\"\n    # Query for scorable match predictions with actual match data\n    predictions_with_match_data = storage.get_match_predictions_to_score(batchsize)\n    edge_scores = []\n    correct_winner_results = []\n    miner_uids = []\n    predictions = []",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "is_match_prediction_valid",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def is_match_prediction_valid(\n    prediction: MatchPrediction, input_synapse: GetMatchPrediction\n) -> Tuple[bool, str]:\n    \"\"\"Performs basic validation on a MatchPrediction.\n    Returns a tuple of (is_valid, reason) where is_valid is True if the entities are valid,\n    and reason is a string describing why they are not valid.\n    \"\"\"\n    # Check if probabilityChoice is None\n    if prediction.probabilityChoice is None:\n        return (",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "post_prediction_edge_results",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def post_prediction_edge_results(\n    vali,\n    prediction_edge_results_endpoint: str,\n    league_scores: Dict[League, List[float]],\n    league_edge_scores: Dict[League, List[float]],\n    league_roi_scores: Dict[League, List[float]],\n    league_roi_counts: Dict[League, List[int]],\n    league_roi_payouts: Dict[League, List[float]],\n    league_roi_market_payouts: Dict[League, List[float]],\n    league_roi_incr_counts: Dict[League, List[int]],",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "redact_scores",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def redact_scores(responses):\n    redacted_responses = []\n    for response in responses:\n        # Create a copy of the response to avoid modifying the original\n        redacted_response = copy.deepcopy(response)\n        # Redact the homeTeamScore, awayTeamScore, probabilityChoice, and probability fields\n        if (\n            hasattr(redacted_response.match_prediction, \"homeTeamScore\")\n            and redacted_response.match_prediction.homeTeamScore is not None\n        ):",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "check_uid_availability",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def check_uid_availability(\n    metagraph: \"bt.metagraph.Metagraph\", uid: int, vpermit_tao_limit: int\n) -> bool:\n    \"\"\"Check if uid is available. The UID should be available if it is serving and has less than vpermit_tao_limit stake\n    Args:\n        metagraph (:obj: bt.metagraph.Metagraph): Metagraph object\n        uid (int): uid to be checked\n        vpermit_tao_limit (int): Validator permit tao limit\n    Returns:\n        bool: True if uid is available, False otherwise",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "get_random_uids",
        "kind": 2,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "def get_random_uids(self, k: int, exclude: List[int] = None) -> List[int]:\n    \"\"\"Returns k available random uids from the metagraph.\n    Args:\n        k (int): Number of uids to return.\n        exclude (List[int]): List of uids to exclude from the random sampling.\n    Returns:\n        uids (List[int]): Randomly sampled available uids.\n    Notes:\n        If `k` is larger than the number of available `uids`, set `k` to the number of available `uids`.\n    \"\"\"",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "storage",
        "kind": 5,
        "importPath": "vali_utils.utils",
        "description": "vali_utils.utils",
        "peekOfCode": "storage = SqliteValidatorStorage.get_instance()\nstorage.initialize()\nasync def sync_match_data(match_data_endpoint) -> bool:\n    try:\n        async with ClientSession() as session:\n            # TODO: add in authentication\n            async with session.get(match_data_endpoint) as response:\n                response.raise_for_status()\n                match_data = await response.json()\n        if not match_data or \"matches\" not in match_data:",
        "detail": "vali_utils.utils",
        "documentation": {}
    },
    {
        "label": "read_requirements",
        "kind": 2,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "def read_requirements(path):\n    with open(path, \"r\") as f:\n        requirements = f.read().splitlines()\n        processed_requirements = []\n        for req in requirements:\n            # For git or other VCS links\n            if req.startswith(\"git+\") or \"@\" in req:\n                pkg_name = re.search(r\"(#egg=)([\\w\\-_]+)\", req)\n                if pkg_name:\n                    processed_requirements.append(pkg_name.group(2))",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "requirements",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "requirements = read_requirements(\"requirements.txt\")\nhere = path.abspath(path.dirname(__file__))\nwith open(path.join(here, \"README.md\"), encoding=\"utf-8\") as f:\n    long_description = f.read()\n# loading version from setup.py\nwith codecs.open(\n    os.path.join(here, \"base/__init__.py\"), encoding=\"utf-8\"\n) as init_file:\n    version_match = re.search(\n        r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", init_file.read(), re.M",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "here",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "here = path.abspath(path.dirname(__file__))\nwith open(path.join(here, \"README.md\"), encoding=\"utf-8\") as f:\n    long_description = f.read()\n# loading version from setup.py\nwith codecs.open(\n    os.path.join(here, \"base/__init__.py\"), encoding=\"utf-8\"\n) as init_file:\n    version_match = re.search(\n        r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", init_file.read(), re.M\n    )",
        "detail": "setup",
        "documentation": {}
    }
]